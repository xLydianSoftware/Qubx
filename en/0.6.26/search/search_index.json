{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qubx - Quantitative Backtesting Framework","text":""},{"location":"#next-generation-of-qube-quantitative-backtesting-framework","title":"Next generation of Qube quantitative backtesting framework","text":"<p>Qubx is a powerful, flexible quantitative backtesting framework designed for developing, testing, and deploying trading strategies. It provides a comprehensive environment for quantitative analysis, backtesting, and live trading.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Robust Backtesting Engine: Test your strategies with historical data</li> <li>Strategy Development: Create and optimize trading strategies</li> <li>Data Management: Handle various data sources and formats</li> <li>Performance Analysis: Evaluate strategy performance with detailed metrics</li> <li>Live Trading: Deploy strategies to live exchanges</li> </ul>"},{"location":"#quick-installation","title":"Quick Installation","text":"<pre><code>pip install qubx\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide</li> <li>Quick Start Tutorial</li> <li>Configuration</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Core Concepts</li> <li>Backtesting</li> <li>Trading</li> <li>Analysis and Reporting</li> <li>API Reference</li> <li>Tutorials and Examples</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"analysis/reporting/","title":"Reporting","text":""},{"location":"analysis/reporting/#introduction-to-reporting","title":"Introduction to Reporting","text":"<p>Effective reporting is essential for analyzing trading strategy performance and communicating results. Qubx provides powerful reporting tools to generate comprehensive, customizable reports in various formats.</p>"},{"location":"analysis/reporting/#report-generation","title":"Report Generation","text":""},{"location":"analysis/reporting/#basic-reports","title":"Basic Reports","text":""},{"location":"analysis/visualization/","title":"Visualization","text":""},{"location":"analysis/visualization/#introduction-to-visualization","title":"Introduction to Visualization","text":"<p>Visualization is a powerful tool for understanding trading strategy performance and market behavior. Qubx provides comprehensive visualization capabilities to help you analyze your strategies and make data-driven decisions.</p>"},{"location":"analysis/visualization/#performance-visualization","title":"Performance Visualization","text":""},{"location":"analysis/visualization/#equity-curve","title":"Equity Curve","text":""},{"location":"backtesting/management/","title":"Backtesting management (from Notebook)","text":""},{"location":"backtesting/management/#storing-restoring-simulation-results","title":"Storing / restoring simulation results","text":"<p>Result of strategy can be stored into the zip file and reloaded from it when needed.</p> <pre><code>r = simualte(...)\nr[0].to_file(\"/tmp/MyTest\") # -&gt; stores data into /tmp/MyTestxxxxxx.zip, xx - timestamp\n\n# now we can load it from file\nr0 = TradingSessionResult.from_file(\"/tmp/MyTest120250130165123.zip\")\n\n# also it's possible to attach some files to result stored to zip\nr[0].to_file(\"/tmp/MyTest\", attachments=[\"config.yaml\"]) # -&gt; also adds config.yaml to zip\n</code></pre> <p>Also it\u2019s possible to generate html report from result</p> <pre><code>r = simualte(...)\nr[0].to_html()\n</code></pre> <p>It\u2019s possible to use small backtests manager (BacktestsResultsManager)</p> <p><pre><code>brm = BacktestsResultsManager(\"/backtests/\")\nbrm.list() # list supports regexp filters \n</code></pre> </p> <p>Then it can load any result by it\u2019s index:</p> <p><code>brm[1]</code> or <code>brm[[2, 6, 7]]</code> etc.</p> <pre><code>tearsheet(brm[[2, 6, 7]])\ntearsheet(brm[1:3)\n</code></pre> <p>to delete: <code>brm.delete(1)</code></p> <p>It\u2019s possible to get table <pre><code>brm.list('.*', as_table=1)\n</code></pre> </p>"},{"location":"backtesting/performance-metrics/","title":"Performance Metrics","text":""},{"location":"backtesting/performance-metrics/#understanding-performance-metrics","title":"Understanding Performance Metrics","text":"<p>Performance metrics help evaluate the effectiveness of trading strategies. Qubx provides a comprehensive set of metrics to analyze strategy performance from different angles.</p>"},{"location":"backtesting/performance-metrics/#standard-performance-indicators","title":"Standard Performance Indicators","text":""},{"location":"backtesting/performance-metrics/#return-metrics","title":"Return Metrics","text":"Metric Description Total Return Total percentage return over the backtest period Annualized Return Return normalized to a yearly basis Daily/Monthly Returns Returns broken down by time periods Compound Annual Growth Rate (CAGR) Smoothed annualized return"},{"location":"backtesting/scheduling/","title":"Scheduling","text":""},{"location":"backtesting/scheduling/#on_fit-schedule","title":"<code>on_fit()</code> schedule","text":"<p>Now it can use custom format</p> <p>\u201cM @ 23:59:55\u201d - first day of every month at 23:59:55</p> <p>\u201cQ @ 15:00\u201d - every quarter start at 15:00</p> <p>\u201c5D @ 10:00\u201d - every 5 days at 10:00</p> <p>\u201cMON @ 9:30\u201d - every Monday at 9:30 (TUE, WED, \u2026..)</p>"},{"location":"backtesting/scheduling/#set_universe","title":"<code>set_universe()</code>","text":"<p>Accepts additional parameter if_has_position_then  </p> <p>It describe what to do with assets requested to remove when they have open position.</p> <p>It can have 3 possible values:</p> <ul> <li>\u201cclose\u201d (default) - close position immediatelly and remove (unsubscribe) instrument from strategy</li> <li>\u201cwait_for_close\u201d - keep instrument and it\u2019s position until it\u2019s closed from strategy (or risk management), then remove instrument from strategy</li> <li>\u201cwait_for_change\u201d - keep instrument and position until strategy would try to change it - then close position and remove instrument</li> </ul>"},{"location":"backtesting/scheduling/#simulate","title":"<code>simulate()</code>","text":"<p>Start / stop can be also expressed in form: </p> <p><code>start=\"2023-06-01\", stop=\"+10d\"</code> - 10 days from start day</p> <p><code>start=\"2023-06-01\", stop=\"-5d\"</code>  - start 5 days before start day</p> <p>data parameter can be configurted to accept different data sources:</p> <pre><code>l1 = loader(....)\ncustom_reader = ....\nr = simulate({'CrossOver MA': TestB(...)}, \n    {                                     \n      'ohlc(1h)': l1,\n      'trade': l1,\n      'quote': l1,\n      '&lt;r&gt;MY_DATA&lt;/r&gt;': custom_reader\n    },\n   1000, ['BINANCE.UM:BTCUSDT'], \"vip0_usdt\", \"2023-07-10\", \"2023-07-11\", debug=\"DEBUG\",\n)\n</code></pre>"},{"location":"backtesting/simulations/","title":"Simulations","text":""},{"location":"backtesting/simulations/#running-simulations-experiments-from-yml-config","title":"Running simulations (experiments) from yml config","text":"<p>It\u2019s possible to make a yml file where we can describe simulation setup. Let\u2019s put config into test1.yml</p> <pre><code>strategy: test.model.Strategy1  # strategy class\n\ndescription: \n  - Description of this experiment\n  - May be multiline\n\nparameters:            # what startegy parameters to use in this run\n  timeframe: \"4h\"\n  parameter1: 123\n\ndata:                  # what data should be used for simulation\n  ohlc(4h): (use_as_aux_loader:=loader(\"BINANCE.UM\", \"4h\", source=\"mqdb::nebula\"))\n\nsimulation:\n  instruments: [\"BINANCE.UM:BTCUSDT\"]\n  capital: 100000.0\n  commissions: \"vip0_usdt\"\n  start: \"2021-01-01\"\n  stop: \"2025-01-21\"\n  aux_data: use_as_aux_loader  # here we could use loader defined in data section !\n  debug: ERROR\n</code></pre> <p>Now we can run it using qubx cli:</p> <pre><code>&gt; qubx simulate test1.yml -o /backtests/tests\n</code></pre> <p>Result will be stored into /backtests/tests folder.</p>"},{"location":"backtesting/simulations/#variations-hyperparameter-optimization","title":"Variations (hyperparameter optimization)","text":"<p>It\u2019s possible to run variations for some parameters (kind of optimization preparation). For that it\u2019s enough to add  variate section:</p> <pre><code>strategy: test.model.Strategy1  # strategy class\n\ndescription: \n  - Description of this experiment\n  - May be multiline\n\nparameters:            # what startegy parameters to use in this run\n  timeframe: \"4h\"\n  parameter1: 123\n  parameter1: 333\n\nvariate:\n  parameter1: [10, 20, 30, 40, 50, 50, 60, 70, 80, 90, 100]\n  parameter2: [10, 20, 30, 40, 50, 50, 60, 70, 80, 90, 100]\n  with:  # here we can apply constraints on parameters\n    parameter1, parameter2: parameter2 &gt; parameter1\n    parameter2: parameter2 &lt;= 90\n\ndata:                  # what data should be used for simulation\n  ohlc(4h): (use_as_aux_loader:=loader(\"BINANCE.UM\", \"4h\", source=\"mqdb::nebula\"))\n\nsimulation:\n  instruments: [\"BINANCE.UM:BTCUSDT\"]\n  capital: 100000.0\n  commissions: \"vip0_usdt\"\n  start: \"2021-01-01\"\n  stop: \"2025-01-21\"\n  debug: ERROR\n</code></pre> <p>Run this using same command</p> <pre><code>&gt; qubx simulate test1.yml -o /backtests/tests\n</code></pre>"},{"location":"core-concepts/backtesting-framework/","title":"Backtesting Framework","text":""},{"location":"core-concepts/backtesting-framework/#architecture-overview","title":"Architecture Overview","text":""},{"location":"core-concepts/data-management/","title":"Data Management","text":""},{"location":"core-concepts/data-management/#data-in-qubx","title":"Data in Qubx","text":"<p>Effective backtesting requires high-quality market data. Qubx provides comprehensive tools for loading, managing, and preprocessing financial data from various sources.</p>"},{"location":"core-concepts/strategies/","title":"Strategies","text":""},{"location":"core-concepts/strategies/#strategy-development","title":"Strategy Development","text":"<p>In Qubx, a strategy is a set of rules that determine when to enter and exit trades. Strategies can range from simple moving average crossovers to complex machine learning models.</p>"},{"location":"core-concepts/strategies/#strategy-interface","title":"Strategy Interface","text":"<p>All strategies in Qubx implement a common interface:</p>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/setup/","title":"Setup","text":""},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Qubx, ensure you have the following:</p> <ul> <li>Python 3.8 or higher</li> <li>pip (Python package installer)</li> <li>Git (for installation from source)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install Qubx is using pip:</p> <pre><code>pip install qubx\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>TODO</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Qubx has been installed correctly:</p> <pre><code>import qubx\nprint(qubx.__version__)\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation:</p> <ul> <li>Ensure you have the latest version of pip: <code>pip install --upgrade pip</code></li> <li>Check that you meet all the prerequisites</li> <li>For dependency conflicts, try installing in a fresh virtual environment</li> <li>For more help, check the GitHub issues or create a new issue </li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":""},{"location":"getting-started/quick-start/#your-first-backtest","title":"Your First Backtest","text":"<p>This guide will walk you through creating and running a simple backtest with Qubx.</p>"},{"location":"getting-started/quick-start/#basic-concepts","title":"Basic Concepts","text":"<p>Before diving in, let's understand some key concepts:</p> <ul> <li>Strategy: A set of rules that determine when to enter and exit trades</li> <li>Backtest: The process of testing a strategy on historical data</li> <li>Data: Historical price and volume information used for backtesting</li> <li>Performance Metrics: Measurements of how well a strategy performs</li> </ul>"},{"location":"getting-started/quick-start/#sample-strategy","title":"Sample Strategy","text":""},{"location":"trading/live-trading/","title":"Live Trading","text":""},{"location":"trading/live-trading/#introduction-to-live-trading","title":"Introduction to Live Trading","text":""},{"location":"trading/paper-trading/","title":"Paper Trading","text":""},{"location":"trading/paper-trading/#introduction-to-paper-trading","title":"Introduction to Paper Trading","text":"<p>Paper trading (also known as simulated trading) allows you to test your trading strategies in real-time market conditions without risking real money. It serves as a bridge between backtesting and live trading, helping you validate your strategy's performance in current market conditions.</p>"},{"location":"trading/paper-trading/#why-use-paper-trading","title":"Why Use Paper Trading?","text":""},{"location":"trading/risk-management/","title":"Risk Management","text":""},{"location":"trading/risk-management/#introduction-to-risk-management","title":"Introduction to Risk Management","text":"<p>Risk management is a critical component of successful trading. Even the best trading strategies can fail without proper risk controls. Qubx provides comprehensive tools for implementing robust risk management in your trading strategies.</p>"},{"location":"trading/risk-management/#position-sizing","title":"Position Sizing","text":"<p>Position sizing determines how much capital to allocate to each trade.</p>"},{"location":"tutorials/data-preparation/","title":"Data Preparation Tutorial","text":""},{"location":"tutorials/data-preparation/#introduction-to-data-management-in-qubx","title":"Introduction to Data Management in Qubx","text":"<p>In quantitative trading, high-quality data is the foundation of successful strategies. This tutorial will guide you through the process of preparing data for use with Qubx.</p>"},{"location":"tutorials/data-preparation/#supported-data-sources","title":"Supported Data Sources","text":""},{"location":"tutorials/deployment/","title":"Deployment","text":"In\u00a0[1]: Copied! <pre>import qubx\n\n%qubxd\n\nimport pandas as pd\nfrom qubx.utils import this_project_root, add_project_to_system_path\nfrom qubx.data.helpers import InMemoryCachedReader\nfrom qubx.backtester.simulator import simulate\nfrom qubx.data import loader\nfrom qubx.core.metrics import tearsheet, chart_signals\n</pre> import qubx  %qubxd  import pandas as pd from qubx.utils import this_project_root, add_project_to_system_path from qubx.data.helpers import InMemoryCachedReader from qubx.backtester.simulator import simulate from qubx.data import loader from qubx.core.metrics import tearsheet, chart_signals <pre>\n\u2800\u2800\u2870\u2856\u2812\u2812\u2892\u28a6\u2800\u2800   \n\u2800\u28a0\u2803\u2808\u2886\u28c0\u28ce\u28c0\u28f1\u2840  QUBX | Quantitative Backtesting Environment \n\u2800\u28b3\u2812\u2812\u285e\u281a\u2844\u2800\u2870\u2801         (c) 2025, ver. 0.5.8\n\u2800\u2800\u2831\u28dc\u28c0\u28c0\u28c8\u28e6\u2803\u2800\u2800\u2800 \n        \n</pre> <p>Adding folder with test strategies to python path to be able to call the imports.</p> In\u00a0[2]: Copied! <pre>PROJECT_ROOT = this_project_root()\nassert PROJECT_ROOT is not None\nadd_project_to_system_path(str(PROJECT_ROOT / \"tests/strategies\"))\n</pre> PROJECT_ROOT = this_project_root() assert PROJECT_ROOT is not None add_project_to_system_path(str(PROJECT_ROOT / \"tests/strategies\")) In\u00a0[3]: Copied! <pre>from macd_crossover.models.macd_crossover import MacdCrossoverStrategy\n\nld: InMemoryCachedReader = loader(  # type: ignore\n    \"BINANCE.UM\", \"1h\", source=f\"csv::{PROJECT_ROOT}/tests/data/csv_1h/\", n_jobs=1\n)\n\ntest0 = simulate(\n    strategies=(stg:=MacdCrossoverStrategy()),\n    data=ld,\n    capital=100_000,\n    instruments=[\"BINANCE.UM:BTCUSDT\"],\n    commissions=\"vip0_usdt\",\n    start=\"2023-06-01\",\n    stop=\"2023-06-10\",\n    debug=\"INFO\",\n)\n</pre> from macd_crossover.models.macd_crossover import MacdCrossoverStrategy  ld: InMemoryCachedReader = loader(  # type: ignore     \"BINANCE.UM\", \"1h\", source=f\"csv::{PROJECT_ROOT}/tests/data/csv_1h/\", n_jobs=1 )  test0 = simulate(     strategies=(stg:=MacdCrossoverStrategy()),     data=ld,     capital=100_000,     instruments=[\"BINANCE.UM:BTCUSDT\"],     commissions=\"vip0_usdt\",     start=\"2023-06-01\",     stop=\"2023-06-10\",     debug=\"INFO\", ) <pre>2023-06-01 00:00:00.000 [\u2139\ufe0f] SimulatedDataProvider.binance.um is initialized\n2023-06-01 00:00:00.000 [\u2139\ufe0f] SimulatedDataProvider ::: Simulation started at 2023-06-01 00:00:00 :::\n</pre> <pre>Simulating:   0%|          | 0/100 [00:00&lt;?, ?%/s]</pre> <pre>2023-06-02 15:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26952.0\n2023-06-02 19:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27183.2\n2023-06-03 03:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27138.5\n2023-06-03 16:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27292.7\n2023-06-03 18:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27147.6\n2023-06-04 08:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27141.0\n2023-06-05 00:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27102.4\n2023-06-06 04:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 25719.8\n2023-06-07 07:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26819.5\n2023-06-08 08:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 26431.5\n2023-06-09 01:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26445.8\n</pre> <pre>2023-06-09 09:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 26632.5\n2023-06-09 16:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26465.1\n2023-06-10 00:59:55.000 [\u2139\ufe0f] SimulatedDataProvider ::: Simulation finished at 2023-06-10 00:00:00 :::\n</pre> In\u00a0[4]: Copied! <pre>tearsheet(test0, plot_leverage=True)\n</pre> tearsheet(test0, plot_leverage=True) Out[4]: Gain Cagr Sharpe Qr Max dd pct Mdd usd Sortino Calmar Tail ratio Stability Var Avg return Fees Execs 6093.911 7.664 4.268 1.58 3.136 3424.373 18.49 252.275 4.011 0.609 3756.992 0.628 1271.419 13.0 <p>First check if the strategy can be found by the <code>qubx</code> CLI.</p> In\u00a0[5]: Copied! <pre>! poetry run qubx ls ../tests/strategies/macd_crossover\n</pre> ! poetry run qubx ls ../tests/strategies/macd_crossover <pre> - /home/yuriy/devs/Qubx/tests/strategies/macd_crossover/models/macd_crossover.py -\n\t.--( MacdCrossoverStrategy : MACD Crossover Strategy. \n\t:  signal_period  : 9\n\t:  slow_period    : 26\n\t:  fast_period    : 12\n\t:  leverage       : 1.0\n\t:  timeframe      : 1h\n\n\n</pre> <p>We can package the strategy and all of its dependencies via <code>qubx release</code>. You can check the available options like this:</p> In\u00a0[6]: Copied! <pre>! poetry run qubx release --help\n</pre> ! poetry run qubx release --help <pre>Usage: qubx release [OPTIONS] [DIRECTORY]\n\n  Releases the strategy to a zip file.\n\n  The strategy can be specified in two ways: 1. As a strategy name (class\n  name) - strategies are scanned in the given directory 2. As a path to a\n  config YAML file containing the strategy configuration in StrategyConfig\n  format\n\n  If a strategy name is provided, a default configuration will be generated\n  with: - The strategy parameters from the strategy class - Default exchange,\n  connector, and instruments from the command options - Standard logging\n  configuration\n\n  If a config file is provided, it must follow the StrategyConfig structure\n  with: - strategy: The strategy name or path - parameters: Dictionary of\n  strategy parameters - exchanges: Dictionary of exchange configurations -\n  aux: Auxiliary configuration - logging: Logging configuration\n\n  All of the dependencies are included in the zip file.\n\nOptions:\n  -s, --strategy TEXT         Strategy name to release (should match the\n                              strategy class name) or path to a config YAML\n                              file  [required]\n  -o, --output-dir TEXT       Output directory to put zip file.  [default:\n                              releases]\n  -t, --tag TEXT              Additional tag for this release (e.g. 'v1.0.0')\n  -m, --message TEXT          Release message (added to the info yaml file).\n  -c, --commit                Commit changes and create tag in repo (default:\n                              False)\n  --default-exchange TEXT     Default exchange to use in the generated config.\n                              [default: BINANCE.UM]\n  --default-connector TEXT    Default connector to use in the generated\n                              config.  [default: ccxt]\n  --default-instruments TEXT  Default instruments to use in the generated\n                              config (comma-separated).  [default: BTCUSDT]\n  --help                      Show this message and exit.\n</pre> In\u00a0[11]: Copied! <pre>! poetry run qubx release \\\n    -s MacdCrossoverStrategy \\\n    -o ../releases \\\n    -m \"Test release\" \\\n    ../tests/strategies/macd_crossover\n</pre> ! poetry run qubx release \\     -s MacdCrossoverStrategy \\     -o ../releases \\     -m \"Test release\" \\     ../tests/strategies/macd_crossover <pre>2025-02-26 14:27:25.461 [ \u2139\ufe0f ] (release) Finding strategy by name: MacdCrossoverStrategy\n2025-02-26 14:27:25.479 [ \u2139\ufe0f ] (release)  - Modified files -\n2025-02-26 14:27:25.488 [ \u26a0\ufe0f ] (release) qubx.cli.release:process_git_repo:687 -  &gt;&gt; Creating git tag is skipped due to --skip-tag option\n2025-02-26 14:27:25.488 [ \u2139\ufe0f ] (release) Creating release pack for R_MacdCrossoverStrategy_20250226142725 ...\n2025-02-26 14:27:26.303 [ \u2139\ufe0f ] (release) Generating poetry.lock file without creating virtual environment...\n2025-02-26 14:27:31.766 [ \u2139\ufe0f ] (release) Created release pack: ../releases/R_MacdCrossoverStrategy_20250226142725.zip\n</pre> In\u00a0[2]: Copied! <pre>! poetry run qubx deploy --force ../releases/R_MacdCrossoverStrategy_20250226142725.zip\n</pre> ! poetry run qubx deploy --force ../releases/R_MacdCrossoverStrategy_20250226142725.zip <pre>2025-02-26 14:32:16.284 [ \u26a0\ufe0f ] (deploy) qubx.cli.deploy:prepare_output_directory:66 - Removing existing directory /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:17.290 [ \u2139\ufe0f ] (deploy) Unpacking /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725.zip to /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:17.294 [ \u2139\ufe0f ] (deploy) Creating Poetry virtual environment\n2025-02-26 14:32:17.295 [ \u2139\ufe0f ] (deploy) Installing dependencies\n2025-02-26 14:32:33.052 [ \u2139\ufe0f ] (deploy) Strategy deployed successfully to /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:33.052 [ \u2139\ufe0f ] (deploy) To run the strategy (paper mode): cd /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper\n</pre> In\u00a0[4]: Copied! <pre>! cd ../releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper\n</pre> ! cd ../releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper <pre>\n\u2800\u2800\u2870\u2856\u2812\u2812\u2892\u28a6\u2800\u2800   \n\u2800\u28a0\u2803\u2808\u2886\u28c0\u28ce\u28c0\u28f1\u2840  QUBX | Quantitative Backtesting Environment \n\u2800\u28b3\u2812\u2812\u285e\u281a\u2844\u2800\u2870\u2801         (c) 2025, ver. 0.5.8\n\u2800\u2800\u2831\u28dc\u28c0\u28c0\u28c8\u28e6\u2803\u2800\u2800\u2800 \n        \n^C\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/deployment/#deployment","title":"Deployment\u00b6","text":"<p>The strategy deployment cycle is explained based on an example of a simple macd crossover strategy located at <code>tests/strategies/macd_crossover</code>.</p>"},{"location":"tutorials/deployment/#1-simulation","title":"1. Simulation\u00b6","text":"<p>First let's make sure that the simulation works as expected.</p>"},{"location":"tutorials/deployment/#2-release","title":"2. Release\u00b6","text":""},{"location":"tutorials/questdb-setup/","title":"QuestDB Setup Tutorial","text":""},{"location":"tutorials/questdb-setup/#introduction-to-questdb","title":"Introduction to QuestDB","text":"<p>QuestDB is a high-performance, open-source time-series database optimized for financial data. Qubx integrates with QuestDB to provide efficient storage and retrieval of market data, making it an excellent choice for backtesting and live trading systems.</p> <p>Key benefits of using QuestDB with Qubx include:</p> <ul> <li>High-performance ingestion and querying</li> <li>SQL interface for data analysis</li> <li>Efficient storage of time-series data</li> <li>Support for real-time and historical data</li> <li>Low latency for time-critical applications</li> </ul>"},{"location":"tutorials/questdb-setup/#installing-questdb","title":"Installing QuestDB","text":""},{"location":"tutorials/questdb-setup/#docker-installation-recommended","title":"Docker Installation (Recommended)","text":"<p>The easiest way to set up QuestDB is using Docker:</p> <pre><code># Pull the latest QuestDB image\ndocker pull questdb/questdb:latest\n\n# Run QuestDB with persistent storage\ndocker run -p 8812:8812 -p 9000:9000 -p 9009:9009 -p 8081:8081 \\\n  -v $(pwd)/questdb-data:/root/.questdb/db \\\n  questdb/questdb:latest\n</code></pre> <p>This will start QuestDB with the following ports: - 8812: PostgreSQL wire protocol - 9000: REST API - 9009: InfluxDB line protocol - 8081: Web Console</p>"},{"location":"tutorials/questdb-setup/#standalone-installation","title":"Standalone Installation","text":"<p>Alternatively, you can install QuestDB as a standalone application:</p> <ol> <li>Download the latest release from QuestDB Releases</li> <li>Extract the archive to a directory of your choice</li> <li>Run QuestDB using the provided scripts:</li> </ol> <pre><code># On Linux/macOS\n./questdb.sh start\n\n# On Windows\nquestdb.bat start\n</code></pre>"},{"location":"tutorials/signal-export/","title":"Signal Export Tutorial","text":"<p>This tutorial explains how to configure and use exporters in Qubx to send trading signals, target positions, and position changes to external systems.</p>"},{"location":"tutorials/signal-export/#overview","title":"Overview","text":"<p>Qubx provides a flexible exporting system that allows you to send trading data to various destinations such as:</p> <ul> <li>Redis Streams</li> <li>Slack</li> <li>Custom exporters</li> </ul> <p>Exporters can be configured in your strategy YAML configuration file and can be customized to export different types of data with different formatting options.</p>"},{"location":"tutorials/signal-export/#configuring-exporters","title":"Configuring Exporters","text":"<p>Exporters are configured in the <code>exporters</code> section of your strategy YAML file. Here's an example configuration:</p> <pre><code>exporters:\n  - exporter: SlackExporter\n    parameters:\n      signals_webhook_url: env:SLACK_WEBHOOK_URL\n      export_signals: true\n      export_targets: true\n      export_position_changes: false\n      strategy_emoji: \":rocket:\"\n      include_account_info: true\n      formatter:\n        class: SlackMessageFormatter\n        args:\n          strategy_emoji: \":chart_with_upwards_trend:\"\n          include_account_info: true\n  - exporter: RedisStreamsExporter\n    parameters:\n      redis_url: env:REDIS_URL\n      signals_stream: strategy_signals\n      export_signals: true\n      export_targets: false\n      export_position_changes: true\n      max_stream_length: 2000\n</code></pre> <p>Each exporter has a <code>parameters</code> section that configures its behavior. The parameters vary depending on the exporter type.</p>"},{"location":"tutorials/signal-export/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>As shown in the example above, you can use environment variables in your configuration by prefixing the value with <code>env:</code>. This is particularly useful for sensitive information like URLs, API keys, and passwords.</p> <p>For example:</p> <pre><code>redis_url: env:REDIS_URL\n</code></pre> <p>This will substitute the value of the <code>REDIS_URL</code> environment variable at runtime. This approach allows you to:</p> <ol> <li>Keep sensitive information out of your configuration files</li> <li>Use different values in different environments (development, testing, production)</li> <li>Easily change configuration without modifying files</li> </ol> <p>Environment variable substitution works for any string parameter in the exporter configuration, including stream names, webhook URLs, and formatter parameters.</p>"},{"location":"tutorials/signal-export/#redis-streams-exporter","title":"Redis Streams Exporter","text":"<p>The Redis Streams Exporter is a powerful way to send trading data to Redis Streams, which can then be consumed by other applications in real-time.</p>"},{"location":"tutorials/signal-export/#configuration","title":"Configuration","text":"<p>Here's a complete example of a Redis Streams Exporter configuration:</p> <pre><code>exporter: RedisStreamsExporter\nparameters:\n  redis_url: env:REDIS_URL\n  signals_stream: strategy:mystrategy:signals\n  targets_stream: strategy:mystrategy:targets\n  position_changes_stream: strategy:mystrategy:position_changes\n  export_signals: true\n  export_targets: true\n  export_position_changes: true\n  max_stream_length: 1000\n  formatter:\n    class: IncrementalFormatter\n    args:\n      alert_name: \"MyStrategy\"\n      exchange_mapping:\n        \"BINANCE.UM\": \"BINANCE_FUTURES\"\n</code></pre>"},{"location":"tutorials/signal-export/#parameters","title":"Parameters","text":"<ul> <li><code>redis_url</code>: Redis connection URL (e.g., \"redis://localhost:6379/0\")</li> <li><code>strategy_name</code>: Name of the strategy (used in stream keys if custom stream names are not provided)</li> <li><code>export_signals</code>: Whether to export signals (default: true)</li> <li><code>export_targets</code>: Whether to export target positions (default: true)</li> <li><code>export_position_changes</code>: Whether to export position changes (default: true)</li> <li><code>signals_stream</code>: Custom stream name for signals (default: \"strategy:{strategy_name}:signals\")</li> <li><code>targets_stream</code>: Custom stream name for target positions (default: \"strategy:{strategy_name}:targets\")</li> <li><code>position_changes_stream</code>: Custom stream name for position changes (default: \"strategy:{strategy_name}:position_changes\")</li> <li><code>max_stream_length</code>: Maximum length of each stream (default: 1000)</li> <li><code>formatter</code>: Formatter to use for formatting data (default: DefaultFormatter)</li> </ul>"},{"location":"tutorials/signal-export/#stream-data-format","title":"Stream Data Format","text":"<p>The Redis Streams Exporter sends data to Redis Streams in a key-value format. The keys and values depend on the formatter used, but the default formatter includes the following fields:</p>"},{"location":"tutorials/signal-export/#signals","title":"Signals","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the signal was generated</li> <li><code>instrument</code>: Symbol of the instrument (e.g., \"BTC-USDT\")</li> <li><code>exchange</code>: Exchange name (e.g., \"BINANCE\")</li> <li><code>direction</code>: Signal direction (-1.0 to 1.0)</li> <li><code>reference_price</code>: Price at which the signal was generated</li> <li><code>group</code>: Signal group (if any)</li> </ul>"},{"location":"tutorials/signal-export/#target-positions","title":"Target Positions","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the target position was generated</li> <li><code>instrument</code>: Symbol of the instrument</li> <li><code>exchange</code>: Exchange name</li> <li><code>target_size</code>: Target position size</li> <li><code>price</code>: Price at which the target position was generated</li> </ul>"},{"location":"tutorials/signal-export/#position-changes","title":"Position Changes","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the position change occurred</li> <li><code>instrument</code>: Symbol of the instrument</li> <li><code>exchange</code>: Exchange name</li> <li><code>price</code>: Price at which the position change occurred</li> <li><code>leverage</code>: Current leverage</li> <li><code>previous_leverage</code>: Previous leverage</li> </ul>"},{"location":"tutorials/signal-export/#consuming-redis-streams","title":"Consuming Redis Streams","text":"<p>You can consume the Redis Streams data using any Redis client that supports Redis Streams. Here's a simple example in Python:</p> <pre><code>import redis\nimport json\n\n# Connect to Redis\nr = redis.from_url(\"redis://localhost:6379/0\")\n\n# Get the last ID we processed (or \"0\" for the beginning of the stream)\nlast_id = \"0\"\n\nwhile True:\n    # Read new messages from the stream\n    response = r.xread(\n        {\n            \"strategy:mystrategy:signals\": last_id,\n            \"strategy:mystrategy:targets\": last_id,\n            \"strategy:mystrategy:position_changes\": last_id,\n        },\n        count=100,\n        block=1000,\n    )\n\n    # Process the messages\n    for stream_name, messages in response:\n        for message_id, data in messages:\n            # Update the last ID\n            last_id = message_id\n\n            # Convert bytes to strings\n            data = {k.decode(): v.decode() for k, v in data.items()}\n\n            # Process the message\n            print(f\"Stream: {stream_name.decode()}, Data: {data}\")\n</code></pre>"},{"location":"tutorials/signal-export/#incremental-formatter","title":"Incremental Formatter","text":"<p>The Incremental Formatter is a specialized formatter for position changes that tracks leverage changes and generates entry/exit messages. This is particularly useful for integration with trading platforms or bots that need to know when to enter or exit positions.</p>"},{"location":"tutorials/signal-export/#configuration_1","title":"Configuration","text":"<pre><code>formatter:\n  class: IncrementalFormatter\n  args:\n    alert_name: \"MyStrategy\"\n    exchange_mapping:\n      \"BINANCE.UM\": \"BINANCE_FUTURES\"\n</code></pre>"},{"location":"tutorials/signal-export/#parameters_1","title":"Parameters","text":"<ul> <li><code>alert_name</code>: The name of the alert to include in the messages</li> <li><code>exchange_mapping</code>: Optional mapping of exchange names to use in messages. If an exchange is not in the mapping, the instrument's exchange is used.</li> </ul>"},{"location":"tutorials/signal-export/#how-it-works","title":"How It Works","text":"<p>The Incremental Formatter tracks leverage changes for each instrument and generates entry/exit messages based on the change in leverage:</p> <ol> <li>When leverage increases (in absolute terms), it generates an ENTRY message with the leverage change.</li> <li>When leverage decreases (in absolute terms), it generates an EXIT message with the exit fraction.</li> <li>When leverage changes sign (from long to short or vice versa), it generates an ENTRY message with the full current leverage.</li> </ol>"},{"location":"tutorials/signal-export/#message-format","title":"Message Format","text":""},{"location":"tutorials/signal-export/#entry-messages","title":"Entry Messages","text":"<pre><code>{\n  \"type\": \"ENTRY\",\n  \"data\": \"{\n    'action':'ENTRY',\n    'exchange':'BINANCE_FUTURES',\n    'alertName':'MyStrategy',\n    'symbol':'BTC-USDT',\n    'side':'BUY',\n    'leverage':0.5,\n    'entryPrice':50000\n  }\"\n}\n</code></pre>"},{"location":"tutorials/signal-export/#exit-messages","title":"Exit Messages","text":"<pre><code>{\n  \"type\": \"EXIT\",\n  \"data\": \"{\n    'action':'EXIT',\n    'exchange':'BINANCE_FUTURES',\n    'alertName':'MyStrategy',\n    'symbol':'BTC-USDT',\n    'exitFraction':0.5,\n    'exitPrice':52000\n  }\"\n}\n</code></pre>"},{"location":"tutorials/signal-export/#custom-formatters","title":"Custom Formatters","text":"<p>You can create custom formatters by extending the <code>DefaultFormatter</code> class or implementing the <code>IExportFormatter</code> interface. This allows you to format the data in any way you need for your specific use case.</p> <p>Here's a simple example of a custom formatter:</p> <pre><code>from qubx.exporters.formatters.base import DefaultFormatter\nfrom qubx.core.basics import Instrument, Signal, TargetPosition, dt_64\nfrom qubx.core.interfaces import IAccountViewer\nfrom typing import Any, Dict\n\nclass MyCustomFormatter(DefaultFormatter):\n    def __init__(self, include_extra_info: bool = False):\n        super().__init__()\n        self.include_extra_info = include_extra_info\n\n    def format_signal(self, time: dt_64, signal: Signal, account: IAccountViewer) -&gt; dict[str, Any]:\n        # Get the default formatting\n        data = super().format_signal(time, signal, account)\n\n        # Add custom fields\n        if self.include_extra_info:\n            data[\"total_capital\"] = str(account.get_total_capital())\n            data[\"available_capital\"] = str(account.get_available_capital())\n\n        return data\n</code></pre> <p>To use your custom formatter, you would configure it in your YAML file:</p> <pre><code>formatter:\n  class: path.to.your.module.MyCustomFormatter\n  args:\n    include_extra_info: true\n</code></pre>"},{"location":"tutorials/signal-export/#multiple-exporters","title":"Multiple Exporters","text":"<p>You can configure multiple exporters to send data to different destinations. For example, you might want to send signals to both Redis Streams and Slack:</p> <pre><code>exporters:\n  - exporter: RedisStreamsExporter\n    parameters:\n      redis_url: env:REDIS_URL\n      export_signals: true\n  - exporter: SlackExporter\n    parameters:\n      signals_webhook_url: env:SLACK_WEBHOOK_URL\n      export_signals: true\n</code></pre> <p>When multiple exporters are configured, Qubx creates a <code>CompositeExporter</code> that forwards all export calls to each of the configured exporters.</p>"},{"location":"tutorials/signal-export/#conclusion","title":"Conclusion","text":"<p>Exporters provide a flexible way to send trading data to external systems. By configuring exporters in your strategy YAML file, you can easily integrate your Qubx strategies with other systems such as monitoring dashboards, trading bots, or notification services.</p> <p>The Redis Streams Exporter with the Incremental Formatter is particularly useful for real-time integration with trading systems, as it provides a standardized way to communicate entry and exit signals.</p> <p>Remember to use environment variable substitution for sensitive information like URLs and API keys to keep your configuration secure and flexible.</p>"}]}