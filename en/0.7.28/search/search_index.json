{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Qubx - Quantitative Backtesting Framework","text":""},{"location":"#next-generation-of-qube-quantitative-backtesting-framework","title":"Next generation of Qube quantitative backtesting framework","text":"<p>Qubx is a powerful, flexible quantitative backtesting framework designed for developing, testing, and deploying trading strategies. It provides a comprehensive environment for quantitative analysis, backtesting, and live trading.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Robust Backtesting Engine: Test your strategies with historical data</li> <li>Strategy Development: Create and optimize trading strategies</li> <li>Data Management: Handle various data sources and formats</li> <li>Performance Analysis: Evaluate strategy performance with detailed metrics</li> <li>Live Trading: Deploy strategies to live exchanges</li> </ul>"},{"location":"#quick-installation","title":"Quick Installation","text":"<pre><code>pip install qubx\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide</li> <li>Quick Start Tutorial</li> <li>Configuration</li> </ul>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Core Concepts</li> <li>Backtesting</li> <li>Trading</li> <li>Analysis and Reporting</li> <li>API Reference</li> <li>Tutorials and Examples</li> </ul>"},{"location":"about/","title":"About","text":""},{"location":"analysis/reporting/","title":"Reporting","text":""},{"location":"analysis/reporting/#introduction-to-reporting","title":"Introduction to Reporting","text":"<p>Effective reporting is essential for analyzing trading strategy performance and communicating results. Qubx provides powerful reporting tools to generate comprehensive, customizable reports in various formats.</p>"},{"location":"analysis/reporting/#report-generation","title":"Report Generation","text":""},{"location":"analysis/reporting/#basic-reports","title":"Basic Reports","text":""},{"location":"analysis/visualization/","title":"Visualization","text":""},{"location":"analysis/visualization/#introduction-to-visualization","title":"Introduction to Visualization","text":"<p>Visualization is a powerful tool for understanding trading strategy performance and market behavior. Qubx provides comprehensive visualization capabilities to help you analyze your strategies and make data-driven decisions.</p>"},{"location":"analysis/visualization/#performance-visualization","title":"Performance Visualization","text":""},{"location":"analysis/visualization/#equity-curve","title":"Equity Curve","text":""},{"location":"backtesting/management/","title":"Backtesting management (from Notebook)","text":""},{"location":"backtesting/management/#storing-restoring-simulation-results","title":"Storing / restoring simulation results","text":"<p>Result of strategy can be stored into the zip file and reloaded from it when needed.</p> <pre><code>r = simualte(...)\nr[0].to_file(\"/tmp/MyTest\") # -&gt; stores data into /tmp/MyTestxxxxxx.zip, xx - timestamp\n\n# now we can load it from file\nr0 = TradingSessionResult.from_file(\"/tmp/MyTest120250130165123.zip\")\n\n# also it's possible to attach some files to result stored to zip\nr[0].to_file(\"/tmp/MyTest\", attachments=[\"config.yaml\"]) # -&gt; also adds config.yaml to zip\n</code></pre> <p>Also it\u2019s possible to generate html report from result</p> <pre><code>r = simualte(...)\nr[0].to_html()\n</code></pre> <p>It\u2019s possible to use small backtests manager (BacktestsResultsManager)</p> <p><pre><code>brm = BacktestsResultsManager(\"/backtests/\")\nbrm.list() # list supports regexp filters \n</code></pre> </p> <p>Then it can load any result by it\u2019s index:</p> <p><code>brm[1]</code> or <code>brm[[2, 6, 7]]</code> etc.</p> <pre><code>tearsheet(brm[[2, 6, 7]])\ntearsheet(brm[1:3)\n</code></pre> <p>to delete: <code>brm.delete(1)</code></p> <p>It\u2019s possible to get table <pre><code>brm.list('.*', as_table=1)\n</code></pre> </p>"},{"location":"backtesting/performance-metrics/","title":"Performance Metrics","text":""},{"location":"backtesting/performance-metrics/#understanding-performance-metrics","title":"Understanding Performance Metrics","text":"<p>Performance metrics help evaluate the effectiveness of trading strategies. Qubx provides a comprehensive set of metrics to analyze strategy performance from different angles.</p>"},{"location":"backtesting/performance-metrics/#standard-performance-indicators","title":"Standard Performance Indicators","text":""},{"location":"backtesting/performance-metrics/#return-metrics","title":"Return Metrics","text":"Metric Description Total Return Total percentage return over the backtest period Annualized Return Return normalized to a yearly basis Daily/Monthly Returns Returns broken down by time periods Compound Annual Growth Rate (CAGR) Smoothed annualized return"},{"location":"backtesting/scheduling/","title":"Scheduling","text":""},{"location":"backtesting/scheduling/#on_fit-schedule","title":"<code>on_fit()</code> schedule","text":"<p>Now it can use custom format</p> <p>\u201cM @ 23:59:55\u201d - first day of every month at 23:59:55</p> <p>\u201cQ @ 15:00\u201d - every quarter start at 15:00</p> <p>\u201c5D @ 10:00\u201d - every 5 days at 10:00</p> <p>\u201cMON @ 9:30\u201d - every Monday at 9:30 (TUE, WED, \u2026..)</p>"},{"location":"backtesting/scheduling/#set_universe","title":"<code>set_universe()</code>","text":"<p>Accepts additional parameter if_has_position_then  </p> <p>It describe what to do with assets requested to remove when they have open position.</p> <p>It can have 3 possible values:</p> <ul> <li>\u201cclose\u201d (default) - close position immediatelly and remove (unsubscribe) instrument from strategy</li> <li>\u201cwait_for_close\u201d - keep instrument and it\u2019s position until it\u2019s closed from strategy (or risk management), then remove instrument from strategy</li> <li>\u201cwait_for_change\u201d - keep instrument and position until strategy would try to change it - then close position and remove instrument</li> </ul>"},{"location":"backtesting/scheduling/#simulate","title":"<code>simulate()</code>","text":"<p>Start / stop can be also expressed in form: </p> <p><code>start=\"2023-06-01\", stop=\"+10d\"</code> - 10 days from start day</p> <p><code>start=\"2023-06-01\", stop=\"-5d\"</code>  - start 5 days before start day</p> <p>data parameter can be configurted to accept different data sources:</p> <pre><code>l1 = loader(....)\ncustom_reader = ....\nr = simulate({'CrossOver MA': TestB(...)}, \n    {                                     \n      'ohlc(1h)': l1,\n      'trade': l1,\n      'quote': l1,\n      '&lt;r&gt;MY_DATA&lt;/r&gt;': custom_reader\n    },\n   1000, ['BINANCE.UM:BTCUSDT'], \"vip0_usdt\", \"2023-07-10\", \"2023-07-11\", debug=\"DEBUG\",\n)\n</code></pre>"},{"location":"backtesting/simulations/","title":"Simulations","text":""},{"location":"backtesting/simulations/#running-simulations-experiments-from-yml-config","title":"Running simulations (experiments) from yml config","text":"<p>It\u2019s possible to make a yml file where we can describe simulation setup. Let\u2019s put config into test1.yml</p> <pre><code>strategy: test.model.Strategy1  # strategy class\n\ndescription: \n  - Description of this experiment\n  - May be multiline\n\nparameters:            # what startegy parameters to use in this run\n  timeframe: \"4h\"\n  parameter1: 123\n\ndata:                  # what data should be used for simulation\n  ohlc(4h): (use_as_aux_loader:=loader(\"BINANCE.UM\", \"4h\", source=\"mqdb::nebula\"))\n\nsimulation:\n  instruments: [\"BINANCE.UM:BTCUSDT\"]\n  capital: 100000.0\n  commissions: \"vip0_usdt\"\n  start: \"2021-01-01\"\n  stop: \"2025-01-21\"\n  aux_data: use_as_aux_loader  # here we could use loader defined in data section !\n  debug: ERROR\n</code></pre> <p>Now we can run it using qubx cli:</p> <pre><code>&gt; qubx simulate test1.yml -o /backtests/tests\n</code></pre> <p>Result will be stored into /backtests/tests folder.</p>"},{"location":"backtesting/simulations/#variations-hyperparameter-optimization","title":"Variations (hyperparameter optimization)","text":"<p>It\u2019s possible to run variations for some parameters (kind of optimization preparation). For that it\u2019s enough to add  variate section:</p> <pre><code>strategy: test.model.Strategy1  # strategy class\n\ndescription: \n  - Description of this experiment\n  - May be multiline\n\nparameters:            # what startegy parameters to use in this run\n  timeframe: \"4h\"\n  parameter1: 123\n  parameter1: 333\n\nvariate:\n  parameter1: [10, 20, 30, 40, 50, 50, 60, 70, 80, 90, 100]\n  parameter2: [10, 20, 30, 40, 50, 50, 60, 70, 80, 90, 100]\n  with:  # here we can apply constraints on parameters\n    parameter1, parameter2: parameter2 &gt; parameter1\n    parameter2: parameter2 &lt;= 90\n\ndata:                  # what data should be used for simulation\n  ohlc(4h): (use_as_aux_loader:=loader(\"BINANCE.UM\", \"4h\", source=\"mqdb::nebula\"))\n\nsimulation:\n  instruments: [\"BINANCE.UM:BTCUSDT\"]\n  capital: 100000.0\n  commissions: \"vip0_usdt\"\n  start: \"2021-01-01\"\n  stop: \"2025-01-21\"\n  debug: ERROR\n</code></pre> <p>Run this using same command</p> <pre><code>&gt; qubx simulate test1.yml -o /backtests/tests\n</code></pre>"},{"location":"core-concepts/backtesting-framework/","title":"Backtesting Framework","text":""},{"location":"core-concepts/backtesting-framework/#architecture-overview","title":"Architecture Overview","text":""},{"location":"core-concepts/data-management/","title":"Data Management","text":""},{"location":"core-concepts/data-management/#data-in-qubx","title":"Data in Qubx","text":"<p>Effective backtesting requires high-quality market data. Qubx provides comprehensive tools for loading, managing, and preprocessing financial data from various sources.</p>"},{"location":"core-concepts/strategies/","title":"Strategies","text":""},{"location":"core-concepts/strategies/#strategy-development","title":"Strategy Development","text":"<p>In Qubx, a strategy is a set of rules that determine when to enter and exit trades. Strategies can range from simple moving average crossovers to complex machine learning models.</p>"},{"location":"core-concepts/strategies/#strategy-interface","title":"Strategy Interface","text":"<p>All strategies in Qubx implement a common interface:</p>"},{"location":"development/build-process/","title":"Build Process","text":"<p>Qubx uses a hybrid build system that compiles both Cython and Rust extensions alongside pure Python code. This document explains how the build process works and how to build, install, and develop with native extensions.</p>"},{"location":"development/build-process/#overview","title":"Overview","text":"<p>The build system consists of:</p> <ul> <li>Poetry - Python package manager and build orchestrator</li> <li>Cython - Compiles <code>.pyx</code> files to C extensions for performance-critical Python code</li> <li>Rust/PyO3 - Compiles Rust code to Python extensions via maturin</li> <li>Custom <code>build.py</code> - Orchestrates both Cython and Rust compilation</li> </ul>"},{"location":"development/build-process/#directory-structure","title":"Directory Structure","text":"<pre><code>Qubx/\n\u251c\u2500\u2500 Cargo.toml                  # Rust workspace manifest (for rust-analyzer)\n\u251c\u2500\u2500 target/                     # Rust build output (shared workspace)\n\u251c\u2500\u2500 src/qubx/\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 series.pyx          # Cython source\n\u2502   \u2502   \u251c\u2500\u2500 series.pxd          # Cython header\n\u2502   \u2502   \u251c\u2500\u2500 series.pyi          # Type stubs\n\u2502   \u2502   \u2514\u2500\u2500 *.so                # Compiled extension\n\u2502   \u251c\u2500\u2500 ta/\n\u2502   \u2502   \u2514\u2500\u2500 indicators.pyx      # Technical analysis indicators\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2502   \u251c\u2500\u2500 ringbuffer.pyx\n\u2502   \u2502   \u2514\u2500\u2500 hft/orderbook.pyx\n\u2502   \u2514\u2500\u2500 _rust/\n\u2502       \u251c\u2500\u2500 __init__.py         # Python wrapper\n\u2502       \u251c\u2500\u2500 __init__.pyi        # Type stubs\n\u2502       \u2514\u2500\u2500 qubx_rust.*.so      # Compiled Rust extension\n\u251c\u2500\u2500 rust/\n\u2502   \u2514\u2500\u2500 qubx_rust/\n\u2502       \u251c\u2500\u2500 Cargo.toml          # Rust crate manifest\n\u2502       \u2514\u2500\u2500 src/lib.rs          # Rust source code\n\u251c\u2500\u2500 build.py                    # Build orchestration script\n\u2514\u2500\u2500 pyproject.toml              # Poetry/build configuration\n</code></pre> <p>The root <code>Cargo.toml</code> defines a Rust workspace, allowing rust-analyzer to properly index the code and providing a shared <code>target/</code> directory for builds.</p>"},{"location":"development/build-process/#build-commands","title":"Build Commands","text":""},{"location":"development/build-process/#full-build-recommended","title":"Full Build (Recommended)","text":"<pre><code># Clean build - removes old artifacts and rebuilds everything\njust build\n</code></pre> <p>This command: 1. Removes the <code>build/</code> directory 2. Removes old <code>.pyd</code> files 3. Runs <code>poetry build</code> which triggers <code>build.py</code></p>"},{"location":"development/build-process/#development-build","title":"Development Build","text":"<pre><code># Install in development mode with all extensions compiled\npoetry install\n</code></pre>"},{"location":"development/build-process/#fast-build-skip-cython","title":"Fast Build (Skip Cython)","text":"<pre><code># Use pre-compiled Cython binaries if they exist\njust build-fast\n</code></pre>"},{"location":"development/build-process/#compile-only-no-wheel","title":"Compile Only (No Wheel)","text":"<pre><code># Just compile Cython and Rust without building a wheel\njust compile\n</code></pre>"},{"location":"development/build-process/#rust-only","title":"Rust Only","text":"<pre><code># Compile Rust code only\njust compile-rust\n\n# Run Rust tests\njust test-rust\n</code></pre>"},{"location":"development/build-process/#how-the-build-works","title":"How the Build Works","text":""},{"location":"development/build-process/#1-build-trigger","title":"1. Build Trigger","text":"<p>When you run <code>poetry build</code> or <code>poetry install</code>, Poetry executes <code>build.py</code> as specified in <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry.build]\nscript = \"build.py\"\n</code></pre>"},{"location":"development/build-process/#2-rust-compilation","title":"2. Rust Compilation","text":"<p>The <code>_build_rust_libs()</code> function in <code>build.py</code>:</p> <ol> <li>Locates the Rust crate at <code>rust/qubx_rust/</code></li> <li>Invokes <code>maturin build</code> to compile the Rust code</li> <li>Extracts the compiled <code>.so</code> file from the wheel</li> <li>Copies it to <code>src/qubx/_rust/</code></li> </ol> <pre><code># Simplified flow\nmaturin build --manifest-path rust/qubx_rust/Cargo.toml --release\n# Output: rust/qubx_rust/target/wheels/qubx_rust-*.whl\n# Extract .so and copy to src/qubx/_rust/\n</code></pre>"},{"location":"development/build-process/#3-cython-compilation","title":"3. Cython Compilation","text":"<p>The Cython build process:</p> <ol> <li>Discovers all <code>.pyx</code> files in <code>src/qubx/</code></li> <li>Transpiles them to C using Cython</li> <li>Compiles C to shared objects using the system compiler</li> <li>Copies <code>.so</code> files back to source tree</li> </ol> <p>Key compiler directives: <pre><code>CYTHON_COMPILER_DIRECTIVES = {\n    \"language_level\": \"3\",\n    \"cdivision\": True,          # 35% speed improvement\n    \"nonecheck\": True,\n    \"embedsignature\": True,\n}\n</code></pre></p>"},{"location":"development/build-process/#4-symbol-stripping","title":"4. Symbol Stripping","text":"<p>For release builds on Linux/macOS, unneeded symbols are stripped from binaries to reduce size.</p>"},{"location":"development/build-process/#build-environment-variables","title":"Build Environment Variables","text":"Variable Default Description <code>BUILD_MODE</code> <code>release</code> Build profile (<code>release</code> or <code>debug</code>) <code>PROFILE_MODE</code> <code>\"\"</code> Enable profiling/tracing <code>ANNOTATION_MODE</code> <code>\"\"</code> Generate Cython HTML annotations <code>PYO3_ONLY</code> <code>false</code> Skip Cython, use existing binaries <code>COPY_TO_SOURCE</code> <code>true</code> Copy compiled files to source tree <p>Example: <pre><code># Debug build with profiling\nBUILD_MODE=debug PROFILE_MODE=1 poetry build\n</code></pre></p>"},{"location":"development/build-process/#adding-new-cython-modules","title":"Adding New Cython Modules","text":"<ol> <li> <p>Create a <code>.pyx</code> file in the appropriate directory:    <pre><code># src/qubx/mymodule/fast_ops.pyx\ndef fast_function(double[:] data):\n    cdef int i\n    cdef double total = 0.0\n    for i in range(data.shape[0]):\n        total += data[i]\n    return total\n</code></pre></p> </li> <li> <p>(Optional) Create a <code>.pxd</code> header for cimports from other modules</p> </li> <li> <p>Create a <code>.pyi</code> stub for type hints:    <pre><code># src/qubx/mymodule/fast_ops.pyi\nimport numpy.typing as npt\ndef fast_function(data: npt.NDArray) -&gt; float: ...\n</code></pre></p> </li> <li> <p>The build system auto-discovers <code>.pyx</code> files - just run <code>just compile</code></p> </li> </ol>"},{"location":"development/build-process/#adding-new-rust-functions","title":"Adding New Rust Functions","text":"<ol> <li> <p>Add functions to <code>rust/qubx_rust/src/lib.rs</code>:    <pre><code>#[pyfunction]\nfn my_function(x: f64) -&gt; f64 {\n    x * 2.0\n}\n\n#[pymodule]\nfn qubx_rust(m: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {\n    m.add_function(wrap_pyfunction!(my_function, m)?)?;\n    Ok(())\n}\n</code></pre></p> </li> <li> <p>Export from Python wrapper <code>src/qubx/_rust/__init__.py</code>:    <pre><code>from qubx._rust.qubx_rust import fibonacci, my_function\n__all__ = [\"fibonacci\", \"my_function\"]\n</code></pre></p> </li> <li> <p>Add type stub to <code>src/qubx/_rust/__init__.pyi</code>:    <pre><code>def my_function(x: float) -&gt; float: ...\n</code></pre></p> </li> <li> <p>Run <code>just compile</code> or <code>poetry build</code></p> </li> </ol>"},{"location":"development/build-process/#testing-native-extensions","title":"Testing Native Extensions","text":""},{"location":"development/build-process/#python-tests","title":"Python Tests","text":"<pre><code># Run all Python tests\njust test\n\n# Test specific module\npoetry run pytest tests/qubx/core/test_series.py -v\n</code></pre>"},{"location":"development/build-process/#rust-tests","title":"Rust Tests","text":"<pre><code># Run Rust unit tests\njust test-rust\n</code></pre>"},{"location":"development/build-process/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/build-process/#maturin-not-found","title":"\"maturin not found\"","text":"<p>Install maturin in your dev environment: <pre><code>poetry install --with dev\n</code></pre></p>"},{"location":"development/build-process/#cython-compilation-errors","title":"Cython compilation errors","text":"<p>Check that you have a C compiler installed: <pre><code># Ubuntu/Debian\nsudo apt install build-essential\n\n# macOS\nxcode-select --install\n</code></pre></p>"},{"location":"development/build-process/#rust-compilation-errors","title":"Rust compilation errors","text":"<p>Ensure Rust is installed: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre></p>"},{"location":"development/build-process/#import-errors-after-rebuild","title":"Import errors after rebuild","text":"<p>Clear Python's import cache: <pre><code>find . -type d -name __pycache__ -exec rm -rf {} +\npoetry install\n</code></pre></p>"},{"location":"development/build-process/#build-artifacts","title":"Build Artifacts","text":"<p>After a successful build, you'll find:</p> <ul> <li><code>dist/qubx-*.whl</code> - Wheel package with all compiled extensions</li> <li><code>dist/qubx-*.tar.gz</code> - Source distribution</li> <li><code>src/qubx/**/*.so</code> - Compiled extensions in source tree (for development)</li> <li><code>build/optimized/</code> - Intermediate Cython build files</li> <li><code>target/</code> - Rust workspace build cache (shared by all crates)</li> </ul>"},{"location":"development/build-process/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use <code>just build-fast</code> during development if Cython modules haven't changed</li> <li>Run <code>just compile</code> for quick iteration on native code</li> <li>Keep Rust's <code>target/</code> directory - incremental compilation is fast</li> <li>The build uses all available CPU cores for parallel compilation</li> </ol>"},{"location":"development/ccxt-requirements/","title":"CCXT Exchange Integration Requirements","text":"<p>This document outlines the required CCXT methods that exchanges must support for full integration with the Qubx quantitative trading framework. The requirements are organized by component (Data Provider, Account Processor, Trading Broker) and based on analysis of the existing codebase.</p>"},{"location":"development/ccxt-requirements/#overview","title":"Overview","text":"<p>Qubx integrates with exchanges through the CCXT library, providing three main services: - Data Provider: Real-time and historical market data - Account Processor: Account balance, position, and order management - Trading Broker: Order execution and management</p>"},{"location":"development/ccxt-requirements/#data-provider-requirements","title":"Data Provider Requirements","text":""},{"location":"development/ccxt-requirements/#market-data-methods","title":"Market Data Methods","text":"Method Purpose Usage in Qubx <code>fetch_ohlcv(symbol, timeframe, since, limit)</code> Historical OHLCV data <code>src/qubx/connectors/ccxt/reader.py:209</code> <code>watch_ohlcv(symbol, timeframe)</code> Real-time OHLCV streams Data streaming handlers <code>watch_orderbook(symbol, limit)</code> Real-time order book Order book subscriptions <code>watch_trades(symbol)</code> Real-time trade feed Trade data subscriptions <code>watch_ticker(symbol)</code> Real-time ticker updates Quote generation <code>fetch_funding_rates(symbols)</code> Current funding rates Funding rate data <code>fetch_funding_rate_history(symbol, since, limit)</code> Historical funding rates <code>src/qubx/connectors/ccxt/reader.py:336</code> <code>watch_funding_rates(symbols)</code> Real-time funding rate updates Custom polling implementation"},{"location":"development/ccxt-requirements/#exchange-information","title":"Exchange Information","text":"Method Purpose Usage in Qubx <code>load_markets()</code> Load market definitions <code>src/qubx/connectors/ccxt/account.py:68</code> <code>find_timeframe(timeframe)</code> Validate timeframe support <code>src/qubx/connectors/ccxt/data.py:219</code>"},{"location":"development/ccxt-requirements/#custom-implementations","title":"Custom Implementations","text":"<p>For exchanges with limited WebSocket support, Qubx provides custom implementations:</p>"},{"location":"development/ccxt-requirements/#hyperliquid-funding-rate-streaming","title":"HyperLiquid Funding Rate Streaming","text":"<pre><code># Located in: src/qubx/connectors/ccxt/exchanges/hyperliquid/hyperliquid.py\nasync def watch_funding_rates(self, symbols, params=None):\n    # Uses PollingToWebSocketAdapter for funding rate updates\n    # Converts polling fetch_funding_rates to WebSocket-like interface\n</code></pre>"},{"location":"development/ccxt-requirements/#extended-ohlcv-format","title":"Extended OHLCV Format","text":"<pre><code>def parse_ohlcv(self, ohlcv, market=None):\n    # Returns 10-field format: [timestamp, open, high, low, close, volume, \n    # volume_quote, trade_count, bought_volume, bought_volume_quote]\n</code></pre>"},{"location":"development/ccxt-requirements/#enhanced-order-parsing","title":"Enhanced Order Parsing","text":"<pre><code>def parse_order(self, order, market=None):\n    # Handles HyperLiquid-specific order format:\n    # - Maps \"limitPx\" presence to limit/market order type\n    # - Converts side \"B\"/\"S\" to \"buy\"/\"sell\"\n    # - Extracts amount from \"sz\" or \"origSz\" fields\n    # - Maps HyperLiquid status to standard CCXT status\n</code></pre>"},{"location":"development/ccxt-requirements/#enhanced-trade-parsing","title":"Enhanced Trade Parsing","text":"<pre><code>def parse_trade(self, trade, market=None):\n    # Handles HyperLiquid-specific trade format:\n    # - Maps side \"B\"/\"S\" to \"buy\"/\"sell\"\n    # - Extracts price from \"px\" field\n    # - Extracts amount from \"sz\" field\n    # - Maps trade ID from \"tid\" field\n</code></pre>"},{"location":"development/ccxt-requirements/#account-processor-requirements","title":"Account Processor Requirements","text":""},{"location":"development/ccxt-requirements/#balance-position-management","title":"Balance &amp; Position Management","text":"Method Purpose Usage in Qubx <code>fetch_balance()</code> Account balances <code>src/qubx/connectors/ccxt/account.py:270</code> <code>fetch_positions()</code> Open positions <code>src/qubx/connectors/ccxt/account.py:295</code> <code>fetch_tickers(symbols)</code> Ticker prices for portfolio valuation <code>src/qubx/connectors/ccxt/account.py:361</code>"},{"location":"development/ccxt-requirements/#order-management","title":"Order Management","text":"Method Purpose Usage in Qubx <code>fetch_orders(symbol, since, limit)</code> Order history <code>src/qubx/connectors/ccxt/account.py:478</code> <code>fetch_open_orders(symbol)</code> Active orders <code>src/qubx/connectors/ccxt/account.py:478</code> <code>fetch_my_trades(symbol, since)</code> Trade/execution history <code>src/qubx/connectors/ccxt/account.py:487</code> <code>watch_orders()</code> Real-time order updates <code>src/qubx/connectors/ccxt/account.py:533</code> <code>cancel_order(id, symbol)</code> Cancel specific order <code>src/qubx/connectors/ccxt/account.py:460</code>"},{"location":"development/ccxt-requirements/#account-processor-integration-points","title":"Account Processor Integration Points","text":"<pre><code># Balance updates every 30 seconds (configurable)\nawait self.exchange.fetch_balance()\n\n# Position updates every 30 seconds (configurable)  \nawait self.exchange.fetch_positions()\n\n# Order execution monitoring\nasync def _watch_executions():\n    exec = await self.exchange.watch_orders()\n    # Process order updates and extract deals\n</code></pre>"},{"location":"development/ccxt-requirements/#trading-broker-requirements","title":"Trading Broker Requirements","text":""},{"location":"development/ccxt-requirements/#order-execution","title":"Order Execution","text":"Method Purpose Usage in Qubx <code>create_order(symbol, type, side, amount, price, params)</code> Place orders <code>src/qubx/connectors/ccxt/broker.py:260</code> <code>create_order_ws(...)</code>* WebSocket order placement <code>src/qubx/connectors/ccxt/broker.py:258</code> <code>cancel_order(id, symbol)</code> Cancel orders <code>src/qubx/connectors/ccxt/broker.py:362</code> <code>cancel_order_ws(id, symbol)</code>* WebSocket order cancellation <code>src/qubx/connectors/ccxt/broker.py:360</code> <p>*Optional WebSocket methods for faster execution</p>"},{"location":"development/ccxt-requirements/#supported-order-types","title":"Supported Order Types","text":"Order Type CCXT Parameters Purpose Market <code>type: \"market\"</code> Immediate execution Limit <code>type: \"limit\"</code> Price-specified execution Stop Market <code>type: \"market\"</code>, <code>params.triggerPrice</code> Stop-loss orders Stop Limit <code>type: \"limit\"</code>, <code>params.triggerPrice</code> Stop orders with limit price"},{"location":"development/ccxt-requirements/#time-in-force-options","title":"Time-in-Force Options","text":"TIF Parameter Behavior GTC <code>params.timeInForce: \"GTC\"</code> Good till canceled GTX <code>params.timeInForce: \"GTX\"</code> Good till crossing (post-only) IOC <code>params.timeInForce: \"IOC\"</code> Immediate or cancel FOK <code>params.timeInForce: \"FOK\"</code> Fill or kill"},{"location":"development/ccxt-requirements/#order-parameters","title":"Order Parameters","text":"<pre><code>{\n    \"symbol\": ccxt_symbol,\n    \"type\": order_type.lower(),  # \"market\", \"limit\"\n    \"side\": order_side.lower(),  # \"buy\", \"sell\"\n    \"amount\": amount,\n    \"price\": price,  # Required for limit orders\n    \"params\": {\n        \"newClientOrderId\": client_id,  # Custom order ID\n        \"timeInForce\": \"GTC\",          # Time in force\n        \"triggerPrice\": price,         # For stop orders\n        \"reduceOnly\": False,           # Position reduction only\n        \"type\": \"swap\"                 # For futures contracts\n    }\n}\n</code></pre>"},{"location":"development/ccxt-requirements/#error-handling","title":"Error Handling","text":"<p>The broker handles various CCXT exceptions:</p> <pre><code># Account-specific errors\nccxt.InsufficientFunds() -&gt; ErrorLevel.HIGH\nccxt.OrderNotFillable() -&gt; ErrorLevel.LOW  \nccxt.InvalidOrder() -&gt; ErrorLevel.LOW\nccxt.BadRequest() -&gt; ErrorLevel.LOW\n\n# Network/Exchange errors (with retry logic)\nccxt.NetworkError()\nccxt.ExchangeError() \nccxt.ExchangeNotAvailable()\nccxt.OperationRejected()\n</code></pre>"},{"location":"development/ccxt-requirements/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"development/ccxt-requirements/#1-market-data-streaming-priority","title":"1. Market Data Streaming Priority","text":"<ul> <li>Implement <code>watch_ohlcv()</code> for real-time price feeds</li> <li>Implement <code>watch_orderbook()</code> for order book data</li> <li>Provide <code>watch_funding_rates()</code> or use polling adapter</li> </ul>"},{"location":"development/ccxt-requirements/#2-account-management-priority","title":"2. Account Management Priority","text":"<ul> <li>Ensure <code>fetch_balance()</code> returns complete balance information</li> <li>Implement <code>fetch_positions()</code> for futures/margin accounts</li> <li>Provide reliable <code>watch_orders()</code> for execution monitoring</li> </ul>"},{"location":"development/ccxt-requirements/#3-order-execution-priority","title":"3. Order Execution Priority","text":"<ul> <li>Support standard order types (market, limit, stop)</li> <li>Implement proper error handling and retry logic</li> <li>Provide WebSocket order methods for low-latency execution</li> </ul>"},{"location":"development/ccxt-requirements/#4-exchange-specific-features","title":"4. Exchange-Specific Features","text":"<p>For HyperLiquid specifically: - Custom funding rate polling via <code>PollingToWebSocketAdapter</code> - Extended OHLCV parsing with trade count data - Proper handling of settlement currencies and futures contracts</p>"},{"location":"development/ccxt-requirements/#5-testing-integration","title":"5. Testing Integration","text":"<p>Ensure the following integration points work correctly: - Market loading and symbol resolution - Real-time data streaming without disconnections - Order placement and cancellation under various market conditions - Account state synchronization during high-frequency updates</p>"},{"location":"development/ccxt-requirements/#references","title":"References","text":"<ul> <li>Core interfaces: <code>src/qubx/core/interfaces.py</code></li> <li>CCXT data provider: <code>src/qubx/connectors/ccxt/data.py</code></li> <li>CCXT account processor: <code>src/qubx/connectors/ccxt/account.py</code> </li> <li>CCXT broker: <code>src/qubx/connectors/ccxt/broker.py</code></li> <li>HyperLiquid implementation: <code>src/qubx/connectors/ccxt/exchanges/hyperliquid/</code></li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":""},{"location":"development/setup/","title":"Setup","text":""},{"location":"getting-started/configuration/","title":"Configuration","text":""},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing Qubx, ensure you have the following:</p> <ul> <li>Python 3.8 or higher</li> <li>pip (Python package installer)</li> <li>Git (for installation from source)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<p>The simplest way to install Qubx is using pip:</p> <pre><code>pip install qubx\n</code></pre>"},{"location":"getting-started/installation/#from-source","title":"From Source","text":"<p>TODO</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Qubx has been installed correctly:</p> <pre><code>import qubx\nprint(qubx.__version__)\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during installation:</p> <ul> <li>Ensure you have the latest version of pip: <code>pip install --upgrade pip</code></li> <li>Check that you meet all the prerequisites</li> <li>For dependency conflicts, try installing in a fresh virtual environment</li> <li>For more help, check the GitHub issues or create a new issue </li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":""},{"location":"getting-started/quick-start/#your-first-backtest","title":"Your First Backtest","text":"<p>This guide will walk you through creating and running a simple backtest with Qubx.</p>"},{"location":"getting-started/quick-start/#basic-concepts","title":"Basic Concepts","text":"<p>Before diving in, let's understand some key concepts:</p> <ul> <li>Strategy: A set of rules that determine when to enter and exit trades</li> <li>Backtest: The process of testing a strategy on historical data</li> <li>Data: Historical price and volume information used for backtesting</li> <li>Performance Metrics: Measurements of how well a strategy performs</li> </ul>"},{"location":"getting-started/quick-start/#sample-strategy","title":"Sample Strategy","text":""},{"location":"trading/live-trading/","title":"Live Trading","text":""},{"location":"trading/live-trading/#introduction-to-live-trading","title":"Introduction to Live Trading","text":""},{"location":"trading/paper-trading/","title":"Paper Trading","text":""},{"location":"trading/paper-trading/#introduction-to-paper-trading","title":"Introduction to Paper Trading","text":"<p>Paper trading (also known as simulated trading) allows you to test your trading strategies in real-time market conditions without risking real money. It serves as a bridge between backtesting and live trading, helping you validate your strategy's performance in current market conditions.</p>"},{"location":"trading/paper-trading/#why-use-paper-trading","title":"Why Use Paper Trading?","text":""},{"location":"trading/risk-management/","title":"Risk Management","text":""},{"location":"trading/risk-management/#introduction-to-risk-management","title":"Introduction to Risk Management","text":"<p>Risk management is a critical component of successful trading. Even the best trading strategies can fail without proper risk controls. Qubx provides comprehensive tools for implementing robust risk management in your trading strategies.</p>"},{"location":"trading/risk-management/#position-sizing","title":"Position Sizing","text":"<p>Position sizing determines how much capital to allocate to each trade.</p>"},{"location":"tutorials/data-preparation/","title":"Data Preparation Tutorial","text":""},{"location":"tutorials/data-preparation/#introduction-to-data-management-in-qubx","title":"Introduction to Data Management in Qubx","text":"<p>In quantitative trading, high-quality data is the foundation of successful strategies. This tutorial will guide you through the process of preparing data for use with Qubx.</p>"},{"location":"tutorials/data-preparation/#supported-data-sources","title":"Supported Data Sources","text":""},{"location":"tutorials/deployment/","title":"Deployment","text":"In\u00a0[1]: Copied! <pre>import qubx\n\n%qubxd\n\nimport pandas as pd\nfrom qubx.utils import this_project_root, add_project_to_system_path\nfrom qubx.data.helpers import InMemoryCachedReader\nfrom qubx.backtester.simulator import simulate\nfrom qubx.data import loader\nfrom qubx.core.metrics import tearsheet, chart_signals\n</pre> import qubx  %qubxd  import pandas as pd from qubx.utils import this_project_root, add_project_to_system_path from qubx.data.helpers import InMemoryCachedReader from qubx.backtester.simulator import simulate from qubx.data import loader from qubx.core.metrics import tearsheet, chart_signals <pre>\n\u2800\u2800\u2870\u2856\u2812\u2812\u2892\u28a6\u2800\u2800   \n\u2800\u28a0\u2803\u2808\u2886\u28c0\u28ce\u28c0\u28f1\u2840  QUBX | Quantitative Backtesting Environment \n\u2800\u28b3\u2812\u2812\u285e\u281a\u2844\u2800\u2870\u2801         (c) 2025, ver. 0.5.8\n\u2800\u2800\u2831\u28dc\u28c0\u28c0\u28c8\u28e6\u2803\u2800\u2800\u2800 \n        \n</pre> <p>Adding folder with test strategies to python path to be able to call the imports.</p> In\u00a0[2]: Copied! <pre>PROJECT_ROOT = this_project_root()\nassert PROJECT_ROOT is not None\nadd_project_to_system_path(str(PROJECT_ROOT / \"tests/strategies\"))\n</pre> PROJECT_ROOT = this_project_root() assert PROJECT_ROOT is not None add_project_to_system_path(str(PROJECT_ROOT / \"tests/strategies\")) In\u00a0[3]: Copied! <pre>from macd_crossover.models.macd_crossover import MacdCrossoverStrategy\n\nld: InMemoryCachedReader = loader(  # type: ignore\n    \"BINANCE.UM\", \"1h\", source=f\"csv::{PROJECT_ROOT}/tests/data/csv_1h/\", n_jobs=1\n)\n\ntest0 = simulate(\n    strategies=(stg:=MacdCrossoverStrategy()),\n    data=ld,\n    capital=100_000,\n    instruments=[\"BINANCE.UM:BTCUSDT\"],\n    commissions=\"vip0_usdt\",\n    start=\"2023-06-01\",\n    stop=\"2023-06-10\",\n    debug=\"INFO\",\n)\n</pre> from macd_crossover.models.macd_crossover import MacdCrossoverStrategy  ld: InMemoryCachedReader = loader(  # type: ignore     \"BINANCE.UM\", \"1h\", source=f\"csv::{PROJECT_ROOT}/tests/data/csv_1h/\", n_jobs=1 )  test0 = simulate(     strategies=(stg:=MacdCrossoverStrategy()),     data=ld,     capital=100_000,     instruments=[\"BINANCE.UM:BTCUSDT\"],     commissions=\"vip0_usdt\",     start=\"2023-06-01\",     stop=\"2023-06-10\",     debug=\"INFO\", ) <pre>2023-06-01 00:00:00.000 [\u2139\ufe0f] SimulatedDataProvider.binance.um is initialized\n2023-06-01 00:00:00.000 [\u2139\ufe0f] SimulatedDataProvider ::: Simulation started at 2023-06-01 00:00:00 :::\n</pre> <pre>Simulating:   0%|          | 0/100 [00:00&lt;?, ?%/s]</pre> <pre>2023-06-02 15:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26952.0\n2023-06-02 19:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27183.2\n2023-06-03 03:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27138.5\n2023-06-03 16:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27292.7\n2023-06-03 18:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27147.6\n2023-06-04 08:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 27141.0\n2023-06-05 00:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 27102.4\n2023-06-06 04:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 25719.8\n2023-06-07 07:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26819.5\n2023-06-08 08:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 26431.5\n2023-06-09 01:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26445.8\n</pre> <pre>2023-06-09 09:00:00.000 [\u2139\ufe0f] BUY signal for BTCUSDT at 26632.5\n2023-06-09 16:00:00.000 [\u2139\ufe0f] SELL signal for BTCUSDT at 26465.1\n2023-06-10 00:59:55.000 [\u2139\ufe0f] SimulatedDataProvider ::: Simulation finished at 2023-06-10 00:00:00 :::\n</pre> In\u00a0[4]: Copied! <pre>tearsheet(test0, plot_leverage=True)\n</pre> tearsheet(test0, plot_leverage=True) Out[4]: Gain Cagr Sharpe Qr Max dd pct Mdd usd Sortino Calmar Tail ratio Stability Var Avg return Fees Execs 6093.911 7.664 4.268 1.58 3.136 3424.373 18.49 252.275 4.011 0.609 3756.992 0.628 1271.419 13.0 <p>First check if the strategy can be found by the <code>qubx</code> CLI.</p> In\u00a0[5]: Copied! <pre>! poetry run qubx ls ../tests/strategies/macd_crossover\n</pre> ! poetry run qubx ls ../tests/strategies/macd_crossover <pre> - /home/yuriy/devs/Qubx/tests/strategies/macd_crossover/models/macd_crossover.py -\n\t.--( MacdCrossoverStrategy : MACD Crossover Strategy. \n\t:  signal_period  : 9\n\t:  slow_period    : 26\n\t:  fast_period    : 12\n\t:  leverage       : 1.0\n\t:  timeframe      : 1h\n\n\n</pre> <p>We can package the strategy and all of its dependencies via <code>qubx release</code>. You can check the available options like this:</p> In\u00a0[6]: Copied! <pre>! poetry run qubx release --help\n</pre> ! poetry run qubx release --help <pre>Usage: qubx release [OPTIONS] [DIRECTORY]\n\n  Releases the strategy to a zip file.\n\n  The strategy can be specified in two ways: 1. As a strategy name (class\n  name) - strategies are scanned in the given directory 2. As a path to a\n  config YAML file containing the strategy configuration in StrategyConfig\n  format\n\n  If a strategy name is provided, a default configuration will be generated\n  with: - The strategy parameters from the strategy class - Default exchange,\n  connector, and instruments from the command options - Standard logging\n  configuration\n\n  If a config file is provided, it must follow the StrategyConfig structure\n  with: - strategy: The strategy name or path - parameters: Dictionary of\n  strategy parameters - exchanges: Dictionary of exchange configurations -\n  aux: Auxiliary configuration - logging: Logging configuration\n\n  All of the dependencies are included in the zip file.\n\nOptions:\n  -s, --strategy TEXT         Strategy name to release (should match the\n                              strategy class name) or path to a config YAML\n                              file  [required]\n  -o, --output-dir TEXT       Output directory to put zip file.  [default:\n                              releases]\n  -t, --tag TEXT              Additional tag for this release (e.g. 'v1.0.0')\n  -m, --message TEXT          Release message (added to the info yaml file).\n  -c, --commit                Commit changes and create tag in repo (default:\n                              False)\n  --default-exchange TEXT     Default exchange to use in the generated config.\n                              [default: BINANCE.UM]\n  --default-connector TEXT    Default connector to use in the generated\n                              config.  [default: ccxt]\n  --default-instruments TEXT  Default instruments to use in the generated\n                              config (comma-separated).  [default: BTCUSDT]\n  --help                      Show this message and exit.\n</pre> In\u00a0[11]: Copied! <pre>! poetry run qubx release \\\n    -s MacdCrossoverStrategy \\\n    -o ../releases \\\n    -m \"Test release\" \\\n    ../tests/strategies/macd_crossover\n</pre> ! poetry run qubx release \\     -s MacdCrossoverStrategy \\     -o ../releases \\     -m \"Test release\" \\     ../tests/strategies/macd_crossover <pre>2025-02-26 14:27:25.461 [ \u2139\ufe0f ] (release) Finding strategy by name: MacdCrossoverStrategy\n2025-02-26 14:27:25.479 [ \u2139\ufe0f ] (release)  - Modified files -\n2025-02-26 14:27:25.488 [ \u26a0\ufe0f ] (release) qubx.cli.release:process_git_repo:687 -  &gt;&gt; Creating git tag is skipped due to --skip-tag option\n2025-02-26 14:27:25.488 [ \u2139\ufe0f ] (release) Creating release pack for R_MacdCrossoverStrategy_20250226142725 ...\n2025-02-26 14:27:26.303 [ \u2139\ufe0f ] (release) Generating poetry.lock file without creating virtual environment...\n2025-02-26 14:27:31.766 [ \u2139\ufe0f ] (release) Created release pack: ../releases/R_MacdCrossoverStrategy_20250226142725.zip\n</pre> In\u00a0[2]: Copied! <pre>! poetry run qubx deploy --force ../releases/R_MacdCrossoverStrategy_20250226142725.zip\n</pre> ! poetry run qubx deploy --force ../releases/R_MacdCrossoverStrategy_20250226142725.zip <pre>2025-02-26 14:32:16.284 [ \u26a0\ufe0f ] (deploy) qubx.cli.deploy:prepare_output_directory:66 - Removing existing directory /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:17.290 [ \u2139\ufe0f ] (deploy) Unpacking /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725.zip to /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:17.294 [ \u2139\ufe0f ] (deploy) Creating Poetry virtual environment\n2025-02-26 14:32:17.295 [ \u2139\ufe0f ] (deploy) Installing dependencies\n2025-02-26 14:32:33.052 [ \u2139\ufe0f ] (deploy) Strategy deployed successfully to /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725\n2025-02-26 14:32:33.052 [ \u2139\ufe0f ] (deploy) To run the strategy (paper mode): cd /home/yuriy/devs/Qubx/releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper\n</pre> In\u00a0[4]: Copied! <pre>! cd ../releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper\n</pre> ! cd ../releases/R_MacdCrossoverStrategy_20250226142725 &amp;&amp; poetry run qubx run config.yml --paper <pre>\n\u2800\u2800\u2870\u2856\u2812\u2812\u2892\u28a6\u2800\u2800   \n\u2800\u28a0\u2803\u2808\u2886\u28c0\u28ce\u28c0\u28f1\u2840  QUBX | Quantitative Backtesting Environment \n\u2800\u28b3\u2812\u2812\u285e\u281a\u2844\u2800\u2870\u2801         (c) 2025, ver. 0.5.8\n\u2800\u2800\u2831\u28dc\u28c0\u28c0\u28c8\u28e6\u2803\u2800\u2800\u2800 \n        \n^C\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"tutorials/deployment/#deployment","title":"Deployment\u00b6","text":"<p>The strategy deployment cycle is explained based on an example of a simple macd crossover strategy located at <code>tests/strategies/macd_crossover</code>.</p>"},{"location":"tutorials/deployment/#1-simulation","title":"1. Simulation\u00b6","text":"<p>First let's make sure that the simulation works as expected.</p>"},{"location":"tutorials/deployment/#2-release","title":"2. Release\u00b6","text":""},{"location":"tutorials/questdb-setup/","title":"QuestDB Setup Tutorial","text":""},{"location":"tutorials/questdb-setup/#introduction-to-questdb","title":"Introduction to QuestDB","text":"<p>QuestDB is a high-performance, open-source time-series database optimized for financial data. Qubx integrates with QuestDB to provide efficient storage and retrieval of market data, making it an excellent choice for backtesting and live trading systems.</p> <p>Key benefits of using QuestDB with Qubx include:</p> <ul> <li>High-performance ingestion and querying</li> <li>SQL interface for data analysis</li> <li>Efficient storage of time-series data</li> <li>Support for real-time and historical data</li> <li>Low latency for time-critical applications</li> </ul>"},{"location":"tutorials/questdb-setup/#installing-questdb","title":"Installing QuestDB","text":""},{"location":"tutorials/questdb-setup/#docker-installation-recommended","title":"Docker Installation (Recommended)","text":"<p>The easiest way to set up QuestDB is using Docker:</p> <pre><code># Pull the latest QuestDB image\ndocker pull questdb/questdb:latest\n\n# Run QuestDB with persistent storage\ndocker run -p 8812:8812 -p 9000:9000 -p 9009:9009 -p 8081:8081 \\\n  -v $(pwd)/questdb-data:/root/.questdb/db \\\n  questdb/questdb:latest\n</code></pre> <p>This will start QuestDB with the following ports: - 8812: PostgreSQL wire protocol - 9000: REST API - 9009: InfluxDB line protocol - 8081: Web Console</p>"},{"location":"tutorials/questdb-setup/#standalone-installation","title":"Standalone Installation","text":"<p>Alternatively, you can install QuestDB as a standalone application:</p> <ol> <li>Download the latest release from QuestDB Releases</li> <li>Extract the archive to a directory of your choice</li> <li>Run QuestDB using the provided scripts:</li> </ol> <pre><code># On Linux/macOS\n./questdb.sh start\n\n# On Windows\nquestdb.bat start\n</code></pre>"},{"location":"tutorials/signal-export/","title":"Signal Export Tutorial","text":"<p>This tutorial explains how to configure and use exporters in Qubx to send trading signals, target positions, and position changes to external systems.</p>"},{"location":"tutorials/signal-export/#overview","title":"Overview","text":"<p>Qubx provides a flexible exporting system that allows you to send trading data to various destinations such as:</p> <ul> <li>Redis Streams</li> <li>Slack</li> <li>Custom exporters</li> </ul> <p>Exporters can be configured in your strategy YAML configuration file and can be customized to export different types of data with different formatting options.</p>"},{"location":"tutorials/signal-export/#configuring-exporters","title":"Configuring Exporters","text":"<p>Exporters are configured in the <code>exporters</code> section of your strategy YAML file. Here's an example configuration:</p> <pre><code>exporters:\n  - exporter: SlackExporter\n    parameters:\n      signals_webhook_url: env:SLACK_WEBHOOK_URL\n      export_signals: true\n      export_targets: true\n      export_position_changes: false\n      strategy_emoji: \":rocket:\"\n      include_account_info: true\n      formatter:\n        class: SlackMessageFormatter\n        args:\n          strategy_emoji: \":chart_with_upwards_trend:\"\n          include_account_info: true\n  - exporter: RedisStreamsExporter\n    parameters:\n      redis_url: env:REDIS_URL\n      signals_stream: strategy_signals\n      export_signals: true\n      export_targets: false\n      export_position_changes: true\n      max_stream_length: 2000\n</code></pre> <p>Each exporter has a <code>parameters</code> section that configures its behavior. The parameters vary depending on the exporter type.</p>"},{"location":"tutorials/signal-export/#environment-variable-substitution","title":"Environment Variable Substitution","text":"<p>As shown in the example above, you can use environment variables in your configuration by prefixing the value with <code>env:</code>. This is particularly useful for sensitive information like URLs, API keys, and passwords.</p> <p>For example:</p> <pre><code>redis_url: env:REDIS_URL\n</code></pre> <p>This will substitute the value of the <code>REDIS_URL</code> environment variable at runtime. This approach allows you to:</p> <ol> <li>Keep sensitive information out of your configuration files</li> <li>Use different values in different environments (development, testing, production)</li> <li>Easily change configuration without modifying files</li> </ol> <p>Environment variable substitution works for any string parameter in the exporter configuration, including stream names, webhook URLs, and formatter parameters.</p>"},{"location":"tutorials/signal-export/#redis-streams-exporter","title":"Redis Streams Exporter","text":"<p>The Redis Streams Exporter is a powerful way to send trading data to Redis Streams, which can then be consumed by other applications in real-time.</p>"},{"location":"tutorials/signal-export/#configuration","title":"Configuration","text":"<p>Here's a complete example of a Redis Streams Exporter configuration:</p> <pre><code>exporter: RedisStreamsExporter\nparameters:\n  redis_url: env:REDIS_URL\n  signals_stream: strategy:mystrategy:signals\n  targets_stream: strategy:mystrategy:targets\n  position_changes_stream: strategy:mystrategy:position_changes\n  export_signals: true\n  export_targets: true\n  export_position_changes: true\n  max_stream_length: 1000\n  formatter:\n    class: IncrementalFormatter\n    args:\n      alert_name: \"MyStrategy\"\n      exchange_mapping:\n        \"BINANCE.UM\": \"BINANCE_FUTURES\"\n</code></pre>"},{"location":"tutorials/signal-export/#parameters","title":"Parameters","text":"<ul> <li><code>redis_url</code>: Redis connection URL (e.g., \"redis://localhost:6379/0\")</li> <li><code>strategy_name</code>: Name of the strategy (used in stream keys if custom stream names are not provided)</li> <li><code>export_signals</code>: Whether to export signals (default: true)</li> <li><code>export_targets</code>: Whether to export target positions (default: true)</li> <li><code>export_position_changes</code>: Whether to export position changes (default: true)</li> <li><code>signals_stream</code>: Custom stream name for signals (default: \"strategy:{strategy_name}:signals\")</li> <li><code>targets_stream</code>: Custom stream name for target positions (default: \"strategy:{strategy_name}:targets\")</li> <li><code>position_changes_stream</code>: Custom stream name for position changes (default: \"strategy:{strategy_name}:position_changes\")</li> <li><code>max_stream_length</code>: Maximum length of each stream (default: 1000)</li> <li><code>formatter</code>: Formatter to use for formatting data (default: DefaultFormatter)</li> </ul>"},{"location":"tutorials/signal-export/#stream-data-format","title":"Stream Data Format","text":"<p>The Redis Streams Exporter sends data to Redis Streams in a key-value format. The keys and values depend on the formatter used, but the default formatter includes the following fields:</p>"},{"location":"tutorials/signal-export/#signals","title":"Signals","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the signal was generated</li> <li><code>instrument</code>: Symbol of the instrument (e.g., \"BTC-USDT\")</li> <li><code>exchange</code>: Exchange name (e.g., \"BINANCE\")</li> <li><code>direction</code>: Signal direction (-1.0 to 1.0)</li> <li><code>reference_price</code>: Price at which the signal was generated</li> <li><code>group</code>: Signal group (if any)</li> </ul>"},{"location":"tutorials/signal-export/#target-positions","title":"Target Positions","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the target position was generated</li> <li><code>instrument</code>: Symbol of the instrument</li> <li><code>exchange</code>: Exchange name</li> <li><code>target_size</code>: Target position size</li> <li><code>price</code>: Price at which the target position was generated</li> </ul>"},{"location":"tutorials/signal-export/#position-changes","title":"Position Changes","text":"<ul> <li><code>timestamp</code>: ISO-formatted timestamp when the position change occurred</li> <li><code>instrument</code>: Symbol of the instrument</li> <li><code>exchange</code>: Exchange name</li> <li><code>price</code>: Price at which the position change occurred</li> <li><code>leverage</code>: Current leverage</li> <li><code>previous_leverage</code>: Previous leverage</li> </ul>"},{"location":"tutorials/signal-export/#consuming-redis-streams","title":"Consuming Redis Streams","text":"<p>You can consume the Redis Streams data using any Redis client that supports Redis Streams. Here's a simple example in Python:</p> <pre><code>import redis\nimport json\n\n# Connect to Redis\nr = redis.from_url(\"redis://localhost:6379/0\")\n\n# Get the last ID we processed (or \"0\" for the beginning of the stream)\nlast_id = \"0\"\n\nwhile True:\n    # Read new messages from the stream\n    response = r.xread(\n        {\n            \"strategy:mystrategy:signals\": last_id,\n            \"strategy:mystrategy:targets\": last_id,\n            \"strategy:mystrategy:position_changes\": last_id,\n        },\n        count=100,\n        block=1000,\n    )\n\n    # Process the messages\n    for stream_name, messages in response:\n        for message_id, data in messages:\n            # Update the last ID\n            last_id = message_id\n\n            # Convert bytes to strings\n            data = {k.decode(): v.decode() for k, v in data.items()}\n\n            # Process the message\n            print(f\"Stream: {stream_name.decode()}, Data: {data}\")\n</code></pre>"},{"location":"tutorials/signal-export/#incremental-formatter","title":"Incremental Formatter","text":"<p>The Incremental Formatter is a specialized formatter for position changes that tracks leverage changes and generates entry/exit messages. This is particularly useful for integration with trading platforms or bots that need to know when to enter or exit positions.</p>"},{"location":"tutorials/signal-export/#configuration_1","title":"Configuration","text":"<pre><code>formatter:\n  class: IncrementalFormatter\n  args:\n    alert_name: \"MyStrategy\"\n    exchange_mapping:\n      \"BINANCE.UM\": \"BINANCE_FUTURES\"\n</code></pre>"},{"location":"tutorials/signal-export/#parameters_1","title":"Parameters","text":"<ul> <li><code>alert_name</code>: The name of the alert to include in the messages</li> <li><code>exchange_mapping</code>: Optional mapping of exchange names to use in messages. If an exchange is not in the mapping, the instrument's exchange is used.</li> </ul>"},{"location":"tutorials/signal-export/#how-it-works","title":"How It Works","text":"<p>The Incremental Formatter tracks leverage changes for each instrument and generates entry/exit messages based on the change in leverage:</p> <ol> <li>When leverage increases (in absolute terms), it generates an ENTRY message with the leverage change.</li> <li>When leverage decreases (in absolute terms), it generates an EXIT message with the exit fraction.</li> <li>When leverage changes sign (from long to short or vice versa), it generates an ENTRY message with the full current leverage.</li> </ol>"},{"location":"tutorials/signal-export/#message-format","title":"Message Format","text":""},{"location":"tutorials/signal-export/#entry-messages","title":"Entry Messages","text":"<pre><code>{\n  \"type\": \"ENTRY\",\n  \"data\": \"{\n    'action':'ENTRY',\n    'exchange':'BINANCE_FUTURES',\n    'alertName':'MyStrategy',\n    'symbol':'BTC-USDT',\n    'side':'BUY',\n    'leverage':0.5,\n    'entryPrice':50000\n  }\"\n}\n</code></pre>"},{"location":"tutorials/signal-export/#exit-messages","title":"Exit Messages","text":"<pre><code>{\n  \"type\": \"EXIT\",\n  \"data\": \"{\n    'action':'EXIT',\n    'exchange':'BINANCE_FUTURES',\n    'alertName':'MyStrategy',\n    'symbol':'BTC-USDT',\n    'exitFraction':0.5,\n    'exitPrice':52000\n  }\"\n}\n</code></pre>"},{"location":"tutorials/signal-export/#target-position-formatter","title":"Target Position Formatter","text":"<p>The Target Position Formatter is a specialized formatter for target positions that creates structured messages with leverage calculations. This is particularly useful for trading systems that need to know target position sizes with leverage expressed as a fraction of total capital.</p>"},{"location":"tutorials/signal-export/#configuration_2","title":"Configuration","text":"<pre><code>exporters:\n  - exporter: RedisStreamsExporter\n    parameters:\n      redis_url: env:REDIS_URL\n      export_targets: true\n      formatter:\n        class: TargetPositionFormatter\n        args:\n          alert_name: \"quarta\"\n          exchange_mapping:\n            \"BINANCE.UM\": \"BINANCE_USDT\"\n</code></pre>"},{"location":"tutorials/signal-export/#parameters_2","title":"Parameters","text":"<ul> <li><code>alert_name</code>: The name of the alert to include in the messages</li> <li><code>exchange_mapping</code>: Optional mapping of exchange names to use in messages. If an exchange is not in the mapping, the instrument's exchange is used.</li> </ul>"},{"location":"tutorials/signal-export/#how-it-works_1","title":"How It Works","text":"<p>The Target Position Formatter formats target positions into structured messages with:</p> <ol> <li>Action: Always set to \"TARGET_POSITION\"</li> <li>Side: \"BUY\" for positive positions, \"SELL\" for negative positions</li> <li>Leverage: Calculated as <code>abs(position_size * price) / total_capital</code></li> <li>Price: Uses <code>entry_price</code> from the target position if available, otherwise falls back to the position's <code>last_update_price</code></li> </ol>"},{"location":"tutorials/signal-export/#message-format_1","title":"Message Format","text":"<pre><code>{\n  \"action\": \"TARGET_POSITION\",\n  \"alertName\": \"quarta\",\n  \"exchange\": \"BINANCE_USDT\",\n  \"symbol\": \"BTCUSDT\",\n  \"side\": \"BUY\",\n  \"leverage\": 0.5\n}\n</code></pre>"},{"location":"tutorials/signal-export/#leverage-calculation","title":"Leverage Calculation","text":"<p>The leverage is calculated as the notional size of the position divided by the total account capital:</p> <pre><code>leverage = abs(target_position_size * price) / total_capital\n</code></pre> <p>For example: - Target position: 0.5 BTC at $50,000 = $25,000 notional - Total capital: $12,000 - Leverage: $25,000 / $12,000 = 2.083 (or 208.3%)</p> <p>This representation makes it easy for downstream systems to understand the position size relative to account capital.</p>"},{"location":"tutorials/signal-export/#custom-formatters","title":"Custom Formatters","text":"<p>You can create custom formatters by extending the <code>DefaultFormatter</code> class or implementing the <code>IExportFormatter</code> interface. This allows you to format the data in any way you need for your specific use case.</p> <p>Here's a simple example of a custom formatter:</p> <pre><code>from qubx.exporters.formatters.base import DefaultFormatter\nfrom qubx.core.basics import Instrument, Signal, TargetPosition, dt_64\nfrom qubx.core.interfaces import IAccountViewer\nfrom typing import Any, Dict\n\nclass MyCustomFormatter(DefaultFormatter):\n    def __init__(self, include_extra_info: bool = False):\n        super().__init__()\n        self.include_extra_info = include_extra_info\n\n    def format_signal(self, time: dt_64, signal: Signal, account: IAccountViewer) -&gt; dict[str, Any]:\n        # Get the default formatting\n        data = super().format_signal(time, signal, account)\n\n        # Add custom fields\n        if self.include_extra_info:\n            data[\"total_capital\"] = str(account.get_total_capital())\n            data[\"available_capital\"] = str(account.get_available_capital())\n\n        return data\n</code></pre> <p>To use your custom formatter, you would configure it in your YAML file:</p> <pre><code>formatter:\n  class: path.to.your.module.MyCustomFormatter\n  args:\n    include_extra_info: true\n</code></pre>"},{"location":"tutorials/signal-export/#multiple-exporters","title":"Multiple Exporters","text":"<p>You can configure multiple exporters to send data to different destinations. For example, you might want to send signals to both Redis Streams and Slack:</p> <pre><code>exporters:\n  - exporter: RedisStreamsExporter\n    parameters:\n      redis_url: env:REDIS_URL\n      export_signals: true\n  - exporter: SlackExporter\n    parameters:\n      signals_webhook_url: env:SLACK_WEBHOOK_URL\n      export_signals: true\n</code></pre> <p>When multiple exporters are configured, Qubx creates a <code>CompositeExporter</code> that forwards all export calls to each of the configured exporters.</p>"},{"location":"tutorials/signal-export/#conclusion","title":"Conclusion","text":"<p>Exporters provide a flexible way to send trading data to external systems. By configuring exporters in your strategy YAML file, you can easily integrate your Qubx strategies with other systems such as monitoring dashboards, trading bots, or notification services.</p> <p>The Redis Streams Exporter with the Incremental Formatter is particularly useful for real-time integration with trading systems, as it provides a standardized way to communicate entry and exit signals.</p> <p>Remember to use environment variable substitution for sensitive information like URLs and API keys to keep your configuration secure and flexible.</p>"}]}