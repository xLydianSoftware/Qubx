import os
import shutil
import subprocess
import tempfile
import zipfile
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest
from click.testing import CliRunner

from qubx.cli.commands import deploy as deploy_command
from qubx.cli.deploy import deploy_strategy


class TestDeployStrategy:
    @pytest.fixture
    def temp_dir(self):
        """Create a temporary directory for testing."""
        temp_dir = tempfile.mkdtemp()
        yield temp_dir
        shutil.rmtree(temp_dir)

    @pytest.fixture
    def mock_zip_file(self, temp_dir):
        """Create a mock zip file for testing."""
        # Create a directory structure to zip
        strategy_dir = os.path.join(temp_dir, "test_strategy")
        os.makedirs(strategy_dir, exist_ok=True)

        # Create a pyproject.toml file
        with open(os.path.join(strategy_dir, "pyproject.toml"), "w") as f:
            f.write("""
[tool.poetry]
name = "test-strategy"
version = "0.1.0"
description = "Test strategy"
authors = ["Test <test@example.com>"]

[tool.poetry.dependencies]
python = "^3.10"
qubx = "^0.1.0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
            """)

        # Create a poetry.lock file
        with open(os.path.join(strategy_dir, "poetry.lock"), "w") as f:
            f.write("# This file is automatically @generated by Poetry.\n")

        # Create a strategy file
        os.makedirs(os.path.join(strategy_dir, "src"), exist_ok=True)
        with open(os.path.join(strategy_dir, "src", "strategy.py"), "w") as f:
            f.write("""
class TestStrategy:
    def __init__(self):
        pass
            """)

        # Create a zip file
        zip_path = os.path.join(temp_dir, "test_strategy.zip")
        with zipfile.ZipFile(zip_path, "w") as zip_ref:
            # Add all files in the strategy_dir to the zip
            for root, _, files in os.walk(strategy_dir):
                for file in files:
                    file_path = os.path.join(root, file)
                    arcname = os.path.relpath(file_path, strategy_dir)
                    zip_ref.write(file_path, arcname)

        # Remove the strategy_dir
        shutil.rmtree(strategy_dir)

        return zip_path

    @patch("subprocess.run")
    def test_deploy_strategy_basic(self, mock_subprocess, temp_dir, mock_zip_file):
        """Test basic functionality of deploy_strategy."""
        # Mock the subprocess.run calls to avoid actual poetry commands
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True on success"

        # Check that the output directory was created
        output_dir = os.path.join(os.path.dirname(mock_zip_file), Path(mock_zip_file).stem)
        assert os.path.exists(output_dir), f"Output directory not created at {output_dir}"

        # Check that the files were extracted
        assert os.path.exists(os.path.join(output_dir, "pyproject.toml")), "pyproject.toml not extracted"
        assert os.path.exists(os.path.join(output_dir, "poetry.lock")), "poetry.lock not extracted"
        assert os.path.exists(os.path.join(output_dir, "src", "strategy.py")), "strategy.py not extracted"

        # Check that subprocess.run was called for poetry commands
        assert mock_subprocess.call_count >= 2, "subprocess.run should be called at least twice"

        # Check the calls to subprocess.run
        calls = mock_subprocess.call_args_list

        # First call should be to configure poetry
        assert "poetry" in calls[0][0][0], "First call should be to poetry"
        assert "config" in calls[0][0][0], "First call should be to poetry config"

        # Second call should be to install dependencies
        assert "poetry" in calls[1][0][0], "Second call should be to poetry"
        assert "install" in calls[1][0][0], "Second call should be to poetry install"

    @patch("subprocess.run")
    def test_deploy_strategy_with_output_dir(self, mock_subprocess, temp_dir, mock_zip_file):
        """Test deploy_strategy with a specified output directory."""
        # Mock the subprocess.run calls to avoid actual poetry commands
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Create a custom output directory
        custom_output_dir = os.path.join(temp_dir, "custom_output")
        os.makedirs(custom_output_dir, exist_ok=True)

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=custom_output_dir, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True on success"

        # Check that the output directory was created
        expected_output_dir = os.path.join(custom_output_dir, Path(mock_zip_file).stem)
        assert os.path.exists(expected_output_dir), f"Output directory not created at {expected_output_dir}"

        # Check that the files were extracted
        assert os.path.exists(os.path.join(expected_output_dir, "pyproject.toml")), "pyproject.toml not extracted"

    @patch("subprocess.run")
    def test_deploy_strategy_force_overwrite(self, mock_subprocess, temp_dir, mock_zip_file):
        """Test deploy_strategy with force overwrite."""
        # Mock the subprocess.run calls to avoid actual poetry commands
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Create a directory that will be overwritten
        output_dir = os.path.join(os.path.dirname(mock_zip_file), Path(mock_zip_file).stem)
        os.makedirs(output_dir, exist_ok=True)
        with open(os.path.join(output_dir, "existing_file.txt"), "w") as f:
            f.write("This file should be deleted")

        # Call the function with force=True
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=True)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True on success"

        # Check that the existing file was deleted
        assert not os.path.exists(os.path.join(output_dir, "existing_file.txt")), "Existing file should be deleted"

        # Check that the files were extracted
        assert os.path.exists(os.path.join(output_dir, "pyproject.toml")), "pyproject.toml not extracted"

    @patch("subprocess.run")
    def test_deploy_strategy_existing_dir_no_force(self, mock_subprocess, temp_dir, mock_zip_file):
        """Test deploy_strategy with existing directory and no force flag."""
        # Create a directory that will not be overwritten
        output_dir = os.path.join(os.path.dirname(mock_zip_file), Path(mock_zip_file).stem)
        os.makedirs(output_dir, exist_ok=True)
        with open(os.path.join(output_dir, "existing_file.txt"), "w") as f:
            f.write("This file should not be deleted")

        # Call the function with force=False
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when directory exists and force=False"

        # Check that the existing file was not deleted
        assert os.path.exists(os.path.join(output_dir, "existing_file.txt")), "Existing file should not be deleted"

    @patch("subprocess.run")
    def test_deploy_strategy_invalid_zip(self, mock_subprocess, temp_dir):
        """Test deploy_strategy with an invalid zip file."""
        # Create an invalid zip file
        invalid_zip = os.path.join(temp_dir, "invalid.zip")
        with open(invalid_zip, "w") as f:
            f.write("This is not a valid zip file")

        # Call the function
        result = deploy_strategy(zip_file=invalid_zip, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False with invalid zip file"

    @patch("subprocess.run")
    def test_deploy_strategy_poetry_error(self, mock_subprocess, temp_dir, mock_zip_file):
        """Test deploy_strategy with a poetry error."""
        # Mock the subprocess.run call to raise an exception
        mock_subprocess.side_effect = subprocess.CalledProcessError(1, "poetry", stderr="Poetry error")

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when poetry fails"

    @patch("qubx.cli.deploy.deploy_strategy")
    def test_deploy_cli_command(self, mock_deploy_strategy, temp_dir, mock_zip_file):
        """Test the CLI command for deploy."""
        # Mock the deploy_strategy function
        mock_deploy_strategy.return_value = True

        # Create a runner
        runner = CliRunner()

        # Run the command
        result = runner.invoke(deploy_command, [mock_zip_file])

        # Check that the command executed successfully
        assert result.exit_code == 0, f"Command failed with: {result.output}"

        # Verify that deploy_strategy was called with the correct arguments
        mock_deploy_strategy.assert_called_once_with(mock_zip_file, None, False)

        # Test with output_dir and force options
        custom_output_dir = os.path.join(temp_dir, "custom_output")
        result = runner.invoke(deploy_command, [mock_zip_file, "--output-dir", custom_output_dir, "--force"])

        # Check that the command executed successfully
        assert result.exit_code == 0, f"Command failed with: {result.output}"

        # Verify that deploy_strategy was called with the correct arguments
        mock_deploy_strategy.assert_called_with(mock_zip_file, custom_output_dir, True)

    @patch("subprocess.run")
    def test_deploy_strategy_not_zip_file(self, mock_subprocess, temp_dir):
        """Test deploy_strategy with a file that doesn't have a .zip extension."""
        # Create a file without .zip extension
        not_zip_file = os.path.join(temp_dir, "not_a_zip")
        with open(not_zip_file, "w") as f:
            f.write("This is not a zip file")

        # Call the function
        result = deploy_strategy(zip_file=not_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False with non-zip file"

    @patch("zipfile.ZipFile.extractall")
    @patch("subprocess.run")
    def test_deploy_strategy_extraction_error(self, mock_subprocess, mock_extractall, temp_dir, mock_zip_file):
        """Test deploy_strategy with an error during zip extraction."""
        # Mock the extractall method to raise a generic exception
        mock_extractall.side_effect = Exception("Extraction error")

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when extraction fails"

    @patch("os.path.exists")
    @patch("subprocess.run")
    def test_deploy_strategy_missing_poetry_lock(self, mock_subprocess, mock_exists, temp_dir, mock_zip_file):
        """Test deploy_strategy with missing poetry.lock file."""

        # Mock os.path.exists to return False for poetry.lock and True for everything else
        def mock_exists_side_effect(path):
            if path.endswith("poetry.lock"):
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to return success for the first call (poetry lock)
        # and raise an exception for the second call (poetry config)
        mock_subprocess.side_effect = [
            MagicMock(returncode=0),  # poetry lock
            subprocess.CalledProcessError(1, "poetry", stderr="Poetry config error"),  # poetry config
        ]

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when poetry config fails"

    @patch("os.path.exists")
    @patch("subprocess.run")
    def test_deploy_strategy_poetry_lock_error(self, mock_subprocess, mock_exists, temp_dir, mock_zip_file):
        """Test deploy_strategy with an error during poetry lock generation."""

        # Mock os.path.exists to return False for poetry.lock and True for everything else
        def mock_exists_side_effect(path):
            if path.endswith("poetry.lock"):
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to raise an exception for the first call (poetry lock)
        mock_subprocess.side_effect = subprocess.CalledProcessError(1, "poetry", stderr="Poetry lock error")

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when poetry lock fails"

    @patch("os.path.exists")
    @patch("subprocess.run")
    @patch("os.makedirs")
    @patch("zipfile.ZipFile")
    def test_deploy_strategy_generate_poetry_lock_success(
        self, mock_zipfile, mock_makedirs, mock_subprocess, mock_exists, temp_dir, mock_zip_file
    ):
        """Test deploy_strategy with successful generation of poetry.lock file."""
        # Mock ZipFile to avoid actual extraction
        mock_zipfile.return_value.__enter__.return_value = MagicMock()

        # Mock os.path.exists for different paths
        def mock_exists_side_effect(path):
            if path.endswith("poetry.lock"):
                return False
            elif path.endswith(Path(mock_zip_file).stem):  # Output directory
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to return success for all calls
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True when poetry.lock is generated successfully"

        # Check that subprocess.run was called for poetry commands
        assert mock_subprocess.call_count >= 3, "subprocess.run should be called at least three times"

        # Check the calls to subprocess.run
        calls = mock_subprocess.call_args_list

        # First call should be to generate poetry.lock
        assert "poetry" in calls[0][0][0], "First call should be to poetry"
        assert "lock" in calls[0][0][0], "First call should be to poetry lock"

        # Second call should be to configure poetry
        assert "poetry" in calls[1][0][0], "Second call should be to poetry"
        assert "config" in calls[1][0][0], "Second call should be to poetry config"

        # Third call should be to install dependencies
        assert "poetry" in calls[2][0][0], "Third call should be to poetry"
        assert "install" in calls[2][0][0], "Third call should be to poetry install"

    @patch("os.path.exists")
    @patch("subprocess.run")
    @patch("os.makedirs")
    @patch("zipfile.ZipFile")
    def test_deploy_strategy_poetry_lock_generation_error(
        self, mock_zipfile, mock_makedirs, mock_subprocess, mock_exists, temp_dir, mock_zip_file
    ):
        """Test deploy_strategy with an error during poetry lock generation."""
        # Mock ZipFile to avoid actual extraction
        mock_zipfile.return_value.__enter__.return_value = MagicMock()

        # Mock os.path.exists for different paths
        def mock_exists_side_effect(path):
            if path.endswith("poetry.lock"):
                return False
            elif path.endswith(Path(mock_zip_file).stem):  # Output directory
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to raise an exception for the poetry lock command
        mock_subprocess.side_effect = subprocess.CalledProcessError(
            1, "poetry lock", stderr="Error generating poetry.lock"
        )

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned False (failure)
        assert result is False, "deploy_strategy should return False when poetry lock generation fails"

        # Check that subprocess.run was called once for the poetry lock command
        mock_subprocess.assert_called_once()

        # Check the call to subprocess.run
        call_args = mock_subprocess.call_args[0][0]
        assert "poetry" in call_args, "Call should be to poetry"
        assert "lock" in call_args, "Call should be to poetry lock"

    @patch("os.path.exists")
    @patch("subprocess.run")
    @patch("os.makedirs")
    @patch("zipfile.ZipFile")
    @patch("os.environ", {"POETRY_ACTIVE": "1", "VIRTUAL_ENV": "/path/to/venv"})
    def test_deploy_strategy_in_poetry_shell(
        self, mock_zipfile, mock_makedirs, mock_subprocess, mock_exists, temp_dir, mock_zip_file
    ):
        """Test deploy_strategy when run from an active Poetry shell."""
        # Mock ZipFile to avoid actual extraction
        mock_zipfile.return_value.__enter__.return_value = MagicMock()

        # Mock os.path.exists for different paths
        def mock_exists_side_effect(path):
            if path.endswith(".venv"):
                return True  # Pretend the .venv directory was created
            elif path.endswith("poetry.lock"):
                return True
            elif path.endswith(Path(mock_zip_file).stem):  # Output directory
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to return success for all calls
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True when run from a Poetry shell"

        # Check that subprocess.run was called for poetry commands
        assert mock_subprocess.call_count >= 2, "subprocess.run should be called at least twice"

        # Check the calls to subprocess.run
        calls = mock_subprocess.call_args_list

        # First call should be to configure poetry
        assert "poetry" in calls[0][0][0], "First call should be to poetry"
        assert "config" in calls[0][0][0], "First call should be to poetry config"

        # Second call should be to install dependencies
        assert "poetry" in calls[1][0][0], "Second call should be to poetry"
        assert "install" in calls[1][0][0], "Second call should be to poetry install"

        # Check that the env parameter was passed to subprocess.run for the install command
        assert "env" in calls[1][1], "The env parameter should be passed to subprocess.run for the install command"

        # Check that POETRY_ACTIVE and VIRTUAL_ENV are not in the environment
        env = calls[1][1]["env"]
        assert "POETRY_ACTIVE" not in env, "POETRY_ACTIVE should not be in the environment"
        assert "VIRTUAL_ENV" not in env, "VIRTUAL_ENV should not be in the environment"

    @patch("os.path.exists")
    @patch("subprocess.run")
    @patch("os.makedirs")
    @patch("zipfile.ZipFile")
    @patch("os.environ", {})  # Empty environment, no Poetry shell
    def test_deploy_strategy_not_in_poetry_shell(
        self, mock_zipfile, mock_makedirs, mock_subprocess, mock_exists, temp_dir, mock_zip_file
    ):
        """Test deploy_strategy when not run from a Poetry shell."""
        # Mock ZipFile to avoid actual extraction
        mock_zipfile.return_value.__enter__.return_value = MagicMock()

        # Mock os.path.exists for different paths
        def mock_exists_side_effect(path):
            if path.endswith(".venv"):
                return True  # Pretend the .venv directory was created
            elif path.endswith("poetry.lock"):
                return True
            elif path.endswith(Path(mock_zip_file).stem):  # Output directory
                return False
            return True

        mock_exists.side_effect = mock_exists_side_effect

        # Mock subprocess.run to return success for all calls
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=None, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True when not in a Poetry shell"

        # Check that subprocess.run was called for poetry commands
        assert mock_subprocess.call_count >= 2, "subprocess.run should be called at least twice"

        # Check the calls to subprocess.run
        calls = mock_subprocess.call_args_list

        # First call should be to configure poetry
        assert "poetry" in calls[0][0][0], "First call should be to poetry"
        assert "config" in calls[0][0][0], "First call should be to poetry config"

        # Second call should be to install dependencies
        assert "poetry" in calls[1][0][0], "Second call should be to poetry"
        assert "install" in calls[1][0][0], "Second call should be to poetry install"

        # Check that the env parameter was NOT passed to subprocess.run for the install command
        assert "env" not in calls[1][1], (
            "The env parameter should NOT be passed to subprocess.run when not in a Poetry shell"
        )

    @patch("os.path.exists")
    @patch("os.path.isdir")
    @patch("subprocess.run")
    @patch("os.makedirs")
    @patch("zipfile.ZipFile")
    def test_deploy_strategy_with_nonexistent_output_dir(
        self, mock_zipfile, mock_makedirs, mock_subprocess, mock_isdir, mock_exists, temp_dir, mock_zip_file
    ):
        """Test deploy_strategy with a non-existent output directory."""
        # Mock ZipFile to avoid actual extraction
        mock_zipfile.return_value.__enter__.return_value = MagicMock()

        # Mock os.path.exists to return False for the output directory
        mock_exists.return_value = False

        # Mock os.path.isdir to return False (not an existing directory)
        mock_isdir.return_value = False

        # Mock subprocess.run to return success for all calls
        mock_subprocess.return_value = MagicMock(returncode=0)

        # Create a non-existent output directory path
        custom_output_dir = os.path.join(temp_dir, "nonexistent_dir")

        # Call the function
        result = deploy_strategy(zip_file=mock_zip_file, output_dir=custom_output_dir, force=False)

        # Check that the function returned True (success)
        assert result is True, "deploy_strategy should return True with non-existent output directory"

        # Check that the output directory was created
        mock_makedirs.assert_called_with(custom_output_dir, exist_ok=True)

        # Check that subprocess.run was called for poetry commands
        assert mock_subprocess.call_count >= 2, "subprocess.run should be called at least twice"
